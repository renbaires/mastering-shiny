---
title: "üöÄ Mastering Shiny - Cap√≠tulo 10: UI Din√°mica"
subtitle: "De Apps Est√°ticas a Experiencias Interactivas que Responden al Usuario"
author: "Basado en el libro de Hadley Wickham"
format: 
  revealjs:
    highlight-style: github
    theme: dark
slide-number: true
chalkboard: true
preview-links: auto
logo: "https://raw.githubusercontent.com/renbaires/2024-12-20-welcome/main/imagenes/logo.png"
css: style.css
editor: source
execute:
  echo: true
warning: false
message: false
---

```{r setup, include=FALSE}
library(shiny)
library(dplyr, warn.conflicts = FALSE)
library(purrr)
library(vroom) # Para el ejemplo de ventas, aunque no lo ejecutaremos directamente por dependencia de archivo
library(openintro, warn.conflicts = FALSE) # Para ejercicio 2
library(usdata)
library(gapminder) # Para ejercicio 3
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.width = 7, fig.height = 5, fig.align = 'center')

# Datos para ejercicio 2
states <- unique(usdata::county$state)

# Datos para ejercicio 3
continents <- unique(gapminder::gapminder$continent)

# Helper para %||% (usado m√°s adelante)
`%||%` <- function(x, y) {
  if (is.null(x)) y else x
}

# --- GENERAR EL TIBBLE 'sales' ---
sales <- tibble(
  TERRITORY = c(
    "EMEA", "EMEA", "EMEA", "EMEA","EMEA", 
    "APAC", "APAC", "APAC", 
    "Japan", "Japan", "NA"
  ),
  CUSTOMERNAME = c(
    "Lyon Souveniers", "Lyon Souveniers", "Berlin Gifts", "Berlin Gifts","Berlin Gifts",
    "Tokyo Traders", "Tokyo Traders", "Sydney Supplies",
    "Kyoto Crafts", "Kyoto Crafts", "Unassigned Client"
  ),
  ORDERNUMBER = c(10101, 10105, 10102, 10106, 10106,20001, 20002, 20003, 30001, 30005, 99999),
  PRODUCTCODE = c("S10_1678", "S10_1949", "S10_2016", "S10_4698", "S10_1678",
                  "S12_1099", "S12_2823", "S12_3380", 
                  "S18_1749", "S18_2248", "S18_3232"),
  QUANTITYORDERED = c(25, 18, 30, 15, 35, 40, 22, 10, 35, 12, 5),
  PRICEEACH = c(54.99, 62.00, 38.50, 95.00, 54.99, 25.00, 31.50, 70.00, 48.00, 51.00, 120.00)
)
```

## üé≠ ¬øAlguna vez han sentido que sus Apps parecen folletos?

::::: columns
::: {.column width="50%"}
### üò¥ Apps Tradicionales:

-   UI definida al inicio
-   "As√≠ como se presenta se queda..."
-   **Usuaria:** "Quisiera que fuera m√°s flexible"
-   **Desarrolladora:** "Trat√© de incluir todas las opciones" ü§∑
:::

::: {.column width="50%"}
### ‚ú® UI Din√°mica:

-   Apps que **RESPONDEN** al usuario
-   Se adaptan en tiempo real
-   **Usuaria:** "¬°Wow, ahora puedo elegir lo que necesito!"
-   **Desarrolladora:** "Hicimos un poco de magia" üßô
:::
:::::

::: notes
¬°Hola a todos y todas y bienvenidos a esta presentaci√≥n sobre el Cap√≠tulo 10 de "Mastering Shiny": UI Din√°mica! Soy Mauro y hoy vamos a transformar nuestras aplicaciones Shiny de robots est√°ticos en asistentes flexibles que le dan participaci√≥n a sus usuarios.

Imaginen por un momento que est√°n usando una aplicaci√≥n web. En el mundo tradicional de Shiny, es como tener un formulario de papel: una vez que lo imprimieron, eso es todo. No importa qu√© escriban en la primera casilla, el resto del formulario sigue igual.

Pero, ¬øqu√© pasar√≠a si ese formulario fuera inteligente? Si cuando escriben "Mendoza" en el campo de Provincia, autom√°ticamente aparecen las ciudades de esa provincia en el siguiente campo. Si cuando seleccionan "an√°lisis avanzado", aparecen controles que antes no estaban ah√≠. Eso es UI din√°mica, y es lo que convierte una herramienta no muy inteligente en una experiencia verdaderamente fluida.

Modificaremos entonces la interfaz de usuario (la UI) en tiempo real, directamente desde "la l√≥gica" de nuestra aplicaci√≥n en la funci√≥n `server`.
:::

------------------------------------------------------------------------

## üõ†Ô∏è3 Problemas y 3 Herramientas "m√°gicas"ü¶â de UI Din√°micas

Hay tres t√©cnicas principales:

1.  **Actualizar Inputs:** Modificar par√°metros de controles existentes (`update*Input()`).
2.  **Visibilidad Din√°mica:** Mostrar/ocultar secciones de UI condicionalmente (`tabsetPanel(type='hidden')`).
3.  **Crear UI con C√≥digo:** Generar UI program√°ticamente desde el servidor (`uiOutput`/`renderUI`).

::: notes
Para lograr esta UI din√°mica, Shiny nos ofrece tres t√©cnicas principales. Cada una tiene sus fortalezas y se adapta mejor a diferentes escenarios.

1.  La primera es **Actualizar Inputs**. Esta es la forma m√°s sencilla y com√∫n de hacer la UI din√°mica. Se trata de modificar los par√°metros de un control de entrada que ya existe en la UI. Por ejemplo, cambiar el valor por defecto, las opciones de un selector, o el rango de un slider. Lo hacemos con la familia de funciones `update*Input()`: por ejemplo updateNumericInput(), updateCheckboxInput(), updateSliderInput() y otra docena de funciones.

2.  La segunda es la **Visibilidad Din√°mica**. Esto nos permite mostrar u ocultar grandes bloques de UI de forma condicional, sin tener que recrearlos. Es muy √∫til para interfaces que cambian dr√°sticamente seg√∫n la elecci√≥n del usuario, como un "asistente" o "wizard" paso a paso. Se usa `tabsetPanel()` con `type = "hidden"`.

3.  Y la tercera, y m√°s flexible, es **Crear UI con C√≥digo**. Esta t√©cnica nos permite generar la interfaz de usuario program√°ticamente desde la funci√≥n `server`, construyendo elementos HTML con funciones de Shiny como `textInput()`, `sliderInput()`, etc. Para esto usamos `uiOutput()` en la UI y `renderUI()` en el servidor. Es la m√°s potente, pero tambi√©n la que requiere m√°s cuidado.

Es importante no perder de vista que estas herramientas son muy poderosas, pero su uso puede aumentar la complejidad de nuestra aplicaci√≥n. Por eso, la recomendaci√≥n es siempre intentar usar la t√©cnica m√°s simple que resuelva tu problema. No uses `renderUI` si un `update*Input` es suficiente.
:::

------------------------------------------------------------------------

## üîÑ Actualizar Inputs: **"Que la p√°gina refleje lo que el usuario quiere"**

-   Modifica controles existentes
-   `update*Input()`
-   M√°s r√°pido y eficiente

::: notes
Empecemos por la primera t√©cnica, actualizar los inputs que ya tenemos en la shiny app.
:::

------------------------------------------------------------------------

### üéÆ Ejemplo B√°sico: Actualizar Rango de Slider

**üí° Objetivo:** Dos `numericInput` controlan el `min` y `max` de un `sliderInput`.

**üéØ C√≥mo:** `observeEvent()` detecta cambios en `input$min` o `input$max` y llama a `updateSliderInput()` üî•.

![](img/actualizar_rango_slider.jpg){width="50%"}

::: notes
Veamos un ejemplo muy sencillo. Nuestro objetivo es permitir que el usuario defina los l√≠mites m√≠nimo y m√°ximo de un `sliderInput` usando dos `numericInput` separados.

En la UI, tenemos tres controles: un `numericInput` para el m√≠nimo, otro para el m√°ximo, y el `sliderInput` que queremos controlar. [‚ñ∂]{style="color: #FF0000;"}
:::

------------------------------------------------------------------------

### üéÆ veamos el script

```{r update-slider-range-app, eval=FALSE}
#| code-line-numbers: "|7-12|7-8|10-11"
#| echo: true
#| RStudio-View: Source

ui <- fluidPage(
  numericInput("min", "M√≠nimo", 0),
  numericInput("max", "M√°ximo", 3),
  sliderInput("n", "n", min = 0, max = 3, value = 1, step = 1)
)
server <- function(input, output, session) {
  observeEvent(input$min, {
    updateSliderInput(session, inputId = "n", min = input$min) #<- session es necesario ahora
  })
  observeEvent(input$max, {
    updateSliderInput(session, inputId = "n", max = input$max) #<- session es necesario ahora
  })
}
shinyApp(ui, server)
```

::: notes
En la UI vemos los inputs que mencionamos...

En el servidor, usamos dos `observeEvent`. [‚ñ∂]{style="color: #00FF00;"}

El primero (l√≠nea 8) escucha los cambios en `input$min`. Cuando `input$min` cambia, llamamos a `updateSliderInput()`. Le pasamos `session` (que siempre es un argumento necesario en estas funciones), el `inputId` del slider que queremos actualizar (que es "n"), y el nuevo valor para el `min` del slider, que es `input$min`. [‚ñ∂]{style="color: #FF0000;"} Hacemos lo mismo para el `input$max` (l√≠nea 11).

Si lo ejecutamos (pueden copiar y pegar el c√≥digo en RStudio para verlo en acci√≥n), ver√°n c√≥mo al cambiar los n√∫meros en las cajas de texto, el rango del slider se ajusta autom√°ticamente. Es un claro ejemplo de c√≥mo la UI reacciona a las acciones del usuario. **PASAMOS A RSTUDIO CON ESC, L 149-168, VERIFICAMOS Y VOLVEMOS CON F** Tambi√©n podr√≠amos ver el siguiente script L182 
:::

------------------------------------------------------------------------

```{r radio_circulo}
#| eval: false
#| include: false
library(shiny)

ui <- fluidPage(
    titlePanel("Intersecci√≥n de una l√≠nea con un circulo"),
    sidebarLayout(
        sidebarPanel(
            numericInput("radio", "Radio del circulo", value = 5, min = 0.1, step = 0.5),
            # Se inicializa con un step peque√±o para permitir decimales
            sliderInput("angulo", "Angulo de la linea (grados)", value = 45, min = 0, max = 90, step = 0.01)
        ),
        mainPanel(
            plotOutput("plot")
        )
    )
)

server <- function(input, output, session) {
    
    # Observador que actualiza el rango y el step del slider del angulo
    # observe({
    #     radioCirculo <- input$radio
    #     centro <- c(10, 10)
    #     # Distancia desde el origen (0,0) hasta el centro del circulo
    #     distancia <- sqrt(centro[1]^2 + centro[2]^2)  # 10*sqrt(2) ~ 14.14
    #     
    #     if (radioCirculo < distancia) {
    #         # Calcula el √°ngulo central y la desviaci√≥n phi
    #         anguloCentral <- atan2(centro[2], centro[1])   # 45¬∞ en radianes
    #         phi <- asin(radioCirculo / distancia)
    #         # Se convierten los extremos a grados y se redondean a dos decimales
    #         anguloMin <- round((anguloCentral - phi) * 180 / pi, 2)
    #         anguloMax <- round((anguloCentral + phi) * 180 / pi, 2)
    #     } else {
    #         # Si el origen est√° dentro del circulo, se permite cualquier √°ngulo
    #         anguloMin <- 0
    #         anguloMax <- 360
    #     }
    #     
    #     # Se ajusta el valor actual si est√° fuera del rango y se redondea
    #     anguloActual <- input$angulo
    #     if (anguloActual < anguloMin || anguloActual > anguloMax) {
    #         anguloActual <- round((anguloMin + anguloMax) / 2, 2)
    #     } else {
    #         anguloActual <- round(anguloActual, 2)
    #     }
    #     
    #     # Se calcula un step basado en el rango, redondeado a dos decimales
    #     paso <- round((anguloMax - anguloMin) / 100, 2)
    #     
    #     updateSliderInput(session, "angulo",
    #                       min = anguloMin,
    #                       max = anguloMax,
    #                       value = anguloActual,
    #                       step = paso)
    # })
    
    # Ese una opci√≥n preferible hacer observeEvent() solo sobre input$radio
    observeEvent(input$radio, {
        radioCirculo <- input$radio
        centro <- c(10, 10)
        distancia <- sqrt(centro[1]^2 + centro[2]^2)

        if (radioCirculo < distancia) {
            anguloCentral <- atan2(centro[2], centro[1])
            phi <- asin(radioCirculo / distancia)
            anguloMin <- round((anguloCentral - phi) * 180 / pi, 2)
            anguloMax <- round((anguloCentral + phi) * 180 / pi, 2)
        } else {
            anguloMin <- 0
            anguloMax <- 360
        }

        anguloActual <- input$angulo
        if (anguloActual < anguloMin || anguloActual > anguloMax) {
            anguloActual <- round((anguloMin + anguloMax) / 2, 2)
        } else {
            anguloActual <- round(anguloActual, 2)
        }

        paso <- round((anguloMax - anguloMin) / 100, 2)

        updateSliderInput(
            session,
            "angulo",
            min = anguloMin,
            max = anguloMax,
            value = anguloActual,
            step = paso
        )
    })
    
    output$plot <- renderPlot({
        radioCirculo <- input$radio
        anguloGrados <- input$angulo
        anguloRadianes <- anguloGrados * pi / 180
        centro_x <- 10
        centro_y <- 10
        
        # Genera las coordenadas del circulo
        secuenciaAngulo <- seq(0, 2 * pi, length.out = 300)
        circulo_x <- centro_x + radioCirculo * cos(secuenciaAngulo)
        circulo_y <- centro_y + radioCirculo * sin(secuenciaAngulo)
        
        # Dibuja el rayo a partir del origen con el angulo especificado
        longitudLinea <- 100  # Suficiente para que cruce el circulo
        linea_x <- c(0, longitudLinea * cos(anguloRadianes))
        linea_y <- c(0, longitudLinea * sin(anguloRadianes))
        
        # Configura y dibuja la gr√°fica
        plot(NA, xlim = c(-5, 30), ylim = c(-5, 30),
             xlab = "X", ylab = "Y", asp = 1,
             main = paste("Radio =", round(radioCirculo, 2),
                          "| Angulo =", round(anguloGrados, 2), "¬∞"))
        lines(circulo_x, circulo_y, col = "blue", lwd = 2)
        lines(linea_x, linea_y, col = "red", lwd = 2)
        points(centro_x, centro_y, col = "blue", pch = 19)
        points(0, 0, col = "black", pch = 19)
        
        # Calcula los puntos de intersecci√≥n entre la l√≠nea y el circulo
        A <- 1
        B <- -2 * (centro_x * cos(anguloRadianes) + centro_y * sin(anguloRadianes))
        C <- centro_x^2 + centro_y^2 - radioCirculo^2
        discriminante <- B^2 - 4 * A * C
        if (discriminante >= 0) {
            t1_inter <- (-B + sqrt(discriminante)) / 2
            t2_inter <- (-B - sqrt(discriminante)) / 2
            tiempos <- sort(c(t1_inter, t2_inter))
            tiempos <- tiempos[tiempos > 0]
            if (length(tiempos) > 0) {
                interseccion_x <- tiempos * cos(anguloRadianes)
                interseccion_y <- tiempos * sin(anguloRadianes)
                points(interseccion_x, interseccion_y, col = "darkgreen", pch = 19, cex = 1.5)
            }
        }
    })
}

shinyApp(ui = ui, server = server)


shinyApp(ui = ui, server = server)



```


------------------------------------------------------------------------

### üé™ Usos Simples: Conveniencia

**1. üîÑ Bot√≥n Reset:** Restaura valores iniciales.

```{r update-reset-app, eval=FALSE}
#| code-line-numbers: "|2-5|9|10-13"
#| echo: true
#| RStudio-View: Showcase

ui <- fluidPage(
  sliderInput("x1", "üìù x1", 0, min = -10, max = 10),
  sliderInput("x2", "üìù x2", 0, min = -10, max = 10),
  sliderInput("x3", "üìù x3", 0, min = -10, max = 10),
  actionButton("reset", "üîÑ Reset", 
               class = "btn-warning")
)

server <- function(input, output, session) {
  observeEvent(input$reset, {
    updateSliderInput(session, inputId = "x1", value = 0)
    updateSliderInput(session, inputId = "x2", value = 0)
    updateSliderInput(session, inputId = "x3", value = 0)
  })
}
shinyApp(ui, server)

```

::: notes
Las funciones `update*Input()` son incre√≠blemente √∫tiles para peque√±os detalles que mejoran la experiencia de usuario.

Un uso muy com√∫n es crear un **Bot√≥n de Reset**. Imaginen que tienen varios controles y el usuario quiere volver a los valores por defecto.

[‚ñ∂]{style="color: #FF0000;"} En este ejemplo, tenemos tres `sliderInput` con valores iniciales de 0, y un `actionButton` con la etiqueta "Reset" (l√≠nea 5).

[‚ñ∂]{style="color: #FF0000;"} En el servidor, simplemente creamos un `observeEvent` que se dispara cuando el bot√≥n "reset" es presionado (l√≠nea 9). [‚ñ∂]{style="color: #FF0000;"} Dentro de este observador, llamamos a `updateSliderInput()` para cada uno de nuestros sliders (`x1`, `x2`, `x3`) y les restablecemos su `value` a 0.

Esto es mucho m√°s limpio que forzar una recarga completa de la aplicaci√≥n para resetear los valores.
:::

------------------------------------------------------------------------

###  üëâüîò Usos Simples: Conveniencia (cont.)

**2. üè∑Ô∏è Etiqueta de Bot√≥n Din√°mica:** Informa al usuario qu√© har√° el bot√≥n .

```{r update-button-label-app, eval=FALSE}
#| code-line-numbers: "|7-10"
#| echo: true
#| RStudio-View: Showcase

ui <- fluidPage(
  numericInput("n", "üî¢  Simulaciones", 10),
  actionButton("simular", "‚ñ∂Ô∏è  Simular")
)

server <- function(input, output, session) {
  observeEvent(input$n, {
    label <- paste0("üöÄ  Simular ", input$n, " veces")
    updateActionButton(session, inputId = "simular", label = label)
  })
}
shinyApp(ui, server)
```

::: notes
Otro uso simple pero efectivo es la **Etiqueta de Bot√≥n Din√°mica**. Esto ayuda a informar al usuario sobre la acci√≥n que realizar√° un bot√≥n, haci√©ndola m√°s espec√≠fica.

Aqu√≠, tenemos un `numericInput` para el n√∫mero de simulaciones y un `actionButton` llamado "simular".

En el servidor, [‚ñ∂]{style="color: #FF0000;"} tenemos un `observeEvent` que reacciona cada vez que el valor de `input$n` (el n√∫mero de simulaciones) cambia. Dentro de este observador, construimos una nueva etiqueta para el bot√≥n, por ejemplo, "Simular 50 veces". Luego, usamos `updateActionButton()` (l√≠nea 9) para actualizar la propiedad `label` de nuestro bot√≥n "simular".

Esto es un peque√±o detalle que mejora la usabilidad, ya que el usuario siempre sabe cu√°ntas simulaciones se ejecutar√°n al hacer clic en el bot√≥n.
:::

------------------------------------------------------------------------

### Un caso que encuentro seguido... en casa üòÅ üç¥üçΩü•Ñ‚ò¢

Contenido sin ordenar

![](img/cajon_desordenado.jpg){width="50%"}

::: notes
Me reservo la foto real de mi caj√≥n de cubiertos... aunque ser√≠a un buen ejemplo de saturaci√≥n de opciones... o seg√∫n el d√≠a de ausencia total de cubiertos.

Si vemos que en nuestros selectores (nuestros inputs), tenemos una sobreabundancia de opciones, con la primer herramienta podremos permitir al usuario actualizar los inputs y establecer una jerarqu√≠a [‚ñ∂]{style="color: #FF0000;"}
:::

------------------------------------------------------------------------

### Soluci√≥n üß†üß†üß†

Contenido organizado en una jerarqu√≠a

![](img/cajones_ordenados.jpg){width="50%"}

------------------------------------------------------------------------

### üåç Caso de Uso: Selectores Jer√°rquicos

::::: columns
::: {.column width="70%"}
**Objetivo:üéØ** Filtrar opciones paso a paso (ej: Territorio -\> Cliente -\> Orden).

**Datos (datos de ventas):** - Territorio contiene Clientes. - Cliente tiene √ìrdenes. - Orden tiene Filas.

**UI:** Tres `selectInput` (Cliente y Orden empiezan con `choices = NULL`) y una `tableOutput`.
:::

::: {.column width="30%"}
![](img/cascading_selection.jpg)
:::
:::::

> **Cliente:** *"Tengo 50,000 √≥rdenes de venta de 20 pa√≠ses, 500 clientes... ¬°pero quiero ver UNA orden espec√≠fica!"*

::: notes
Pasemos a un caso de uso m√°s avanzado y muy com√∫n: los **Selectores Jer√°rquicos**.

Imaginen que tienen un conjunto de datos grande, como datos de ventas, donde las categor√≠as est√°n anidadas: un Territorio contiene Clientes, un Cliente tiene √ìrdenes, y cada Orden tiene sus propias filas de detalles.

El objetivo es permitir al usuario filtrar los datos paso a paso. Primero selecciona un Territorio, luego las opciones para el Cliente se actualizan bas√°ndose en ese Territorio, luego las √ìrdenes se actualizan bas√°ndose en el Cliente, y finalmente vemos los detalles de la Orden.

En lugar de enfrentar 50,000 opciones, el usuario navega a trav√©s de 4 territorios, luego tal vez 10 clientes, luego quiz√°s 5 √≥rdenes (si ese cliente particular no ten√≠a tantas ordenes). ¬°Mucho m√°s f√°cil y directo!
:::

------------------------------------------------------------------------

### üß≠üåç Selectores Jer√°rquicos: UI

```{r hierarchical-ui, eval=FALSE, }
#| echo: true
# Sales data no est√° disponible aqu√≠, solo mostramos UI
# sales <- vroom::vroom("sales_data_sample.csv", ...) 
library(shiny)

ui <- fluidPage(
  selectInput(inputId = "territory",
              label = "üåç Territory",
              choices = c("NA", "EMEA", "APAC", "Japan")),
  selectInput("customername", "üè¢ Customer", choices = NULL),
  selectInput("ordernumber", "üìã Order number", choices = NULL),
  tableOutput("data")
)
```

::: notes
En la UI (como se muestra en el c√≥digo), tenemos tres `selectInput`: uno para el Territorio, otro para el Cliente, y otro para el N√∫mero de Orden. Noten que los selectores de Cliente y Orden comienzan con `choices = NULL`, porque sus opciones se rellenar√°n din√°micamente. Y finalmente, un `tableOutput` para mostrar los datos filtrados.

El archivo de datos de ventas real no estaba disponible en el libro pero hice unos pocos datos sint√©ticos con una IA. **EJECUTAR UI PRIMERO**
:::

------------------------------------------------------------------------

###  üß≠üåç Selectores Jer√°rquicos: L√≥gica del Servidor

**C√≥mo:** Se usa una cadena de reactivos y `observeEvent` / `updateSelectInput`.

1.  el reactive `territory()`: Filtra `sales` por `input$territory`.
2.  `observeEvent(territory(), ...)`: Actualiza `choices` de `input$customername`.
3.  el reactive `customer()`: Filtra `territory()` por `input$customername`. (Usa `req(input$customername)` para esperar selecci√≥n).
4.  `observeEvent(customer(), ...)`: Actualiza `choices` de `input$ordernumber`.
5.  `renderTable()`: Muestra datos filtrados finales (Usa `req(input$ordernumber)`).

::: notes
Esto ser√≠a el paso a paso para que quede en la presentaci√≥n... vamos a ver el c√≥digo y les voy contando.
:::

------------------------------------------------------------------------

###  üß≠üåç Selectores Jer√°rquicos: An√°lisis del Script

```{r hierarchical-server, eval=FALSE}
#| echo: true
#| code-line-numbers: "1-39|3-9|9-13|15-19|21-25|27-33"
# C√≥digo conceptual - requiere datos 'sales'
server <- function(input, output, session) {
  # 1. üîÑ REACTIVO: Filtra por territorio
  territory <- reactive({
    req(input$territory) # Asegura que hay una selecci√≥n
    filter(sales, TERRITORY == input$territory)
  })
  
  # 2. üëÄ OBSERVADOR: Actualiza clientes basado en territorio
  observeEvent(territory(), {
    choices <- unique(territory()$CUSTOMERNAME)
    updateSelectInput(session, inputId = "customername", choices = choices) 
  })
  
  # 3. üîÑ REACTIVO: Filtra por cliente
  customer <- reactive({
    req(input$customername) # Espera selecci√≥n de cliente
    filter(territory(), CUSTOMERNAME == input$customername) 
  })
  
  # 4. üëÄ OBSERVADOR: Actualiza √≥rdenes basado en cliente
  observeEvent(customer(), {
    choices <- unique(customer()$ORDERNUMBER)
    updateSelectInput(session, inputId = "ordernumber", choices = choices)
  })
  
  # 5. üìä OUTPUT: Muestra datos de la orden seleccionada
  output$data <- renderTable({
    req(input$ordernumber) # Espera selecci√≥n de orden
    customer() %>% filter(ORDERNUMBER == input$ordernumber) %>% select(everything())
  })
}
shinyApp(ui, server)
```

::: notes
Aqu√≠ es donde reside la magia de los selectores jer√°rquicos. Es una cadena de reactividad:

[‚ñ∂]{style="color: #FF0000;"}

1.  Primero, tenemos un reactivo llamado `territory` que reacciona a `input$territory`. Este reactivo realiza el filtrado de los datos de ventas para obtener solo registros para los clientes de ese territorio. El `req(input$territory)` asegura que este reactivo solo se ejecute cuando un territorio haya sido seleccionado.

[‚ñ∂]{style="color: #FF0000;"}

2.  Luego, tenemos un `observeEvent` que escucha los cambios en el reactivo `territory()`. Cuando la lista de clientes del territorio cambia, este observador actualiza las opciones del `selectInput` del cliente (`customername`) usando `updateSelectInput()`.

[‚ñ∂]{style="color: #FF0000;"}

3.  El patr√≥n se repite: un reactivo `customer` filtra los datos del `territory()` bas√°ndose en `input$customername`, y usa `req()` para esperar la selecci√≥n.

[‚ñ∂]{style="color: #FF0000;"}

4.  Otro `observeEvent` escucha a `customer()` y actualiza las opciones del `selectInput` de la orden (`ordernumber`).

[‚ñ∂]{style="color: #FF0000;"}

5.  Finalmente, `renderTable` muestra los datos, asegur√°ndose con require `req()` que haya una orden seleccionada antes de intentar filtrar y mostrar.

Es demostraci√≥n de c√≥mo los reactivos y observadores se encadenan para crear una experiencia de usuario altamente interactiva y dependiente del contexto. De alguna forma se asemeja a filtrar una planilla en Excel.
:::

------------------------------------------------------------------------

### üßä Congelar Inputs Reactivos (`freezeReactiveValue()`)

::::: columns
::: {.column width="70%"}
**Problema:** En jerarqu√≠as, cambiar el input superior (ej: `dataset`) puede causar un "parpadeo" o error temporal en los outputs que dependen del input inferior (ej: `column`), porque el inferior a√∫n no se ha actualizado. Temporalmente, `input$column` puede tener un valor inv√°lido para el nuevo `input$dataset`.

**Ejemplo:** Seleccionar Dataset -\> Seleccionar Columna -\> Mostrar Resumen.
:::

::: {.column width="30%"}
![](img/summary_null.jpg)
:::
:::::

------------------------------------------------------------------------

### üßä Congelar Inputs Reactivos - Script:

```{r freeze-problem-app, eval=FALSE}
#| code-line-numbers: "1-22|2|3|4|2,8,11-14|16-20|19"
#| echo: true
#| RStudio-View: Showcase

ui <- fluidPage(
  selectInput("dataset", "Choose a dataset", c("pressure", "cars")),
  selectInput("column", "Choose column", character(0)), # Empieza vac√≠o
  verbatimTextOutput("summary")
)

server <- function(input, output, session) {
  dataset <- reactive(get(input$dataset, "package:datasets"))
  
  # Actualiza las columnas cuando cambia el dataset
  observeEvent(input$dataset, {
    # ¬°SIN freezeReactiveValue! - Puede causar parpadeo/error
    updateSelectInput(session, inputId = "column", choices = names(dataset()))
  })
  
  output$summary <- renderPrint({
    # Se ejecuta ANTES de que input$column se actualice completamente
    req(input$column) # <- Evita el error inicial, pero no el parpadeo
    summary(dataset()[[input$column]]) 
  })
}
shinyApp(ui, server)
```

> **Resultado:** Parpadeo de error entre cambios üòµ‚Äçüí´

::: notes
Analicemos el c√≥digo.

Imagina este escenario: [‚ñ∂]{style="color: #FF0000;"}tienes un `selectInput` para elegir un dataset (por ejemplo, "pressure" o "cars"), y [‚ñ∂]{style="color: #FF0000;"}otro `selectInput` para elegir una columna *de ese dataset*. [‚ñ∂]{style="color: #FF0000;"}Finalmente, un `verbatimTextOutput` muestra un resumen de la columna seleccionada.

El problema es el siguiente: [‚ñ∂]{style="color: #FF0000;"}cuando cambias el dataset (por ejemplo, de "pressure" a "cars"), el `observeEvent` se dispara para actualizar las opciones del `selectInput` de la columna. Sin embargo, antes de que esa actualizaci√≥n se complete y la UI se refresque con las nuevas opciones, [‚ñ∂]{style="color: #FF0000;"}el `output$summary` podr√≠a intentar recalcularse.

En ese breve instante, `input$column` todav√≠a tiene el valor de la columna *vieja* (ej: "temperature" de `pressure`), pero `dataset()` ya apunta al *nuevo* dataset (`cars`). [‚ñ∂]{style="color: #FF0000;"}Intentar hacer `summary(cars[["temperature"]])` causar√° un error, o un "parpadeo" de `NULL`s, porque "temperature" no existe en el dataset "cars". Si pudi√©ramos llegar a leerlo ver√≠amos Length 0, Class NULL y Mode NULL. El `req(input$column)` ayuda a evitar un error si `input$column` es `NULL` al inicio, pero no soluciona el parpadeo cuando el valor se vuelve inv√°lido temporalmente.
:::

------------------------------------------------------------------------

### üßä Congelar Inputs Reactivos: ‚ú® La Soluci√≥n

**Soluci√≥n:** `freezeReactiveValue(input, "inputId")`

**C√≥mo:** Le dice a Shiny que ignore temporalmente cualquier cambio en `input$inputId` hasta que la actualizaci√≥n (`update*Input`) se complete y todo el sistema est√© sincronizado de nuevo. Previene que reactivos/outputs usen un valor "obsoleto" mientras la actualizaci√≥n est√° en curso. Cuando vemos el cap√≠tulo 14, en particular "14.4 An input changes", podremos ver c√≥mo lo que est√° haciendo este congelamiento es impedir la reejecuci√≥n de todos los reactivos y outputs que dependen de ese input (14.4.4 Re-execution), pero toma nota de cu√°les son... porque luego los recalcular√°. 

::: notes
Si hici√©ramos una lluvia de ideas... ¬øqu√© opciones tenemos para evitar evaluar summary(NULL)?

Una que podr√≠a ayudar es:
-   Envolver tu summary() con req(input\$columna %in% names(data)) para que no se ejecute hasta que la columna exista.
-   Controlar el orden de reactividad con isolate(), que ya veremos

Otras no tanto:
-   Si no fuera este caso usar√≠amos las funciones shiny::validate() o shiny::need() para mostrar un mensaje "Elige primero una columna v√°lida" en lugar de un espacio en blanco. Ser√≠a un parpadeo explicado, pero no resolver√≠a el problema de fondo.
-   Par√°metros de prioridad en observeEvent(input$data, priority = 1e10) se ejecutar√° antes que otro observeEvent(), pero en este caso el problema no es porque haya otro observeEvent() que est√© compitiendo.
:::

------------------------------------------------------------------------

### üßä Congelar Inputs Reactivos: script resuelto

```{r freeze-solution-app, eval=FALSE}
#| code-line-numbers: "|11-14|16-19"
#| echo: true
#| RStudio-View: Showcase

# ui es el mismo que antes
ui <- fluidPage(
  selectInput("dataset", "üìä Choose a dataset", c("pressure", "cars")),
  selectInput("column", "üìã Choose column", character(0)),
  verbatimTextOutput("summary")
)

server <- function(input, output, session) {
  dataset <- reactive(get(input$dataset, "package:datasets"))
  
  observeEvent(input$dataset, {
    freezeReactiveValue(input, "column") #  üßä <--- ¬°EVITA INVALIDAR  output$summary !
    updateSelectInput(session, inputId = "column", choices = names(dataset()))
  })
  
  output$summary <- renderPrint({
    req(input$column) 
    summary(dataset()[[input$column]])
  })
}
shinyApp(ui, server)
```

**Buena pr√°ctica:** Usar `freezeReactiveValue` siempre que actualices din√°micamente un valor de input que otros reactivos/outputs usen.

::: notes
La soluci√≥n a este problema es la funci√≥n `freezeReactiveValue()`.

[‚ñ∂]{style="color: #FF0000;"} Lo que hace `freezeReactiveValue(input, "column")` (l√≠nea 12) es decirle a Shiny: "Ojo, s√© que el valor de `input$column` va a cambiar pronto, pero mientras hago esta actualizaci√≥n de sus opciones (de hecho hasta que todo el dominio reactivo sea refrescado), por favor, no permitas que ning√∫n otro reactivo o output se dispare si solo est√° reaccionando a un cambio transitorio o potencialmente inv√°lido en `input$column`."

Esto efectivamente "congela" la reactividad del input `column` hasta que `updateSelectInput` termina su trabajo y `input$column` se establece a su nuevo valor (generalmente la primera opci√≥n de la lista). [‚ñ∂]{style="color: #FF0000;"} As√≠, el `output$summary` no intentar√° calcularse con un `input$column` obsoleto o inv√°lido. Es una buena pr√°ctica usar `freezeReactiveValue` siempre que actualizamos din√°micamente un input que sea una dependencia de otros reactivos u outputs (o sea, depende de que algo m√°s cambie). Evita errores y mejora la experiencia de usuario eliminando esos "parpadeos".
:::

------------------------------------------------------------------------

### üßä Congelar Inputs Reactivos: Ejemplo de la Help Documentation: ?freezeReactiveValue

```{r}
#| eval: false
library(shiny)
ui <- fluidPage(
  selectInput("data", "Data Set", c("mtcars", "pressure")),
  checkboxGroupInput("cols", "Columns (select 2)", character(0)),
  plotOutput("plot")
)

server <- function(input, output, session) {
  observe({
    data <- get(input$data)
    # Sets a flag on input$cols to essentially do req(FALSE) if input$cols
    # is accessed. Without this, an error will momentarily show whenever a
    # new data set is selected.
    freezeReactiveValue(input, "cols")
    updateCheckboxGroupInput(session, "cols", choices = names(data))
  })

  output$plot <- renderPlot({
    # When a new data set is selected, input$cols will have been invalidated
    # above, and this will essentially do the same as req(FALSE), causing
    # this observer to stop and raise a silent exception.
    cols <- input$cols
    data <- get(input$data)

    if (length(cols) == 2) {
      plot(data[[ cols[1] ]], data[[ cols[2] ]])
    }
  })
}

shinyApp(ui, server)
```

::: notes
No vamos a ver este ejemplo al detalle, pero es interesante comentar la l√≠nea de freezeReactiveValue (en la l√≠nea 14 si incluimos los comentarios en el conteo de l√≠neas) para ver c√≥mo es el error que se est√° resolviendo con esta funci√≥n, as√≠ cuando lo veamos en el futuro asociemos este tipo de error a esta soluci√≥n. Spoiler: da una cadena de error de shoy resaltando 178: renderPlot \[#19\]
:::

------------------------------------------------------------------------

### üå™ Referencias Circulares

**¬°Peligro!** Usar `update*Input` para cambiar el `value` de un input puede crear bucles infinitos si ese mismo input *dispara* la actualizaci√≥n.

**Ejemplo Trivial (¬°No hacer!):**

```{r circular-bad-app, eval=FALSE}
#| echo: true
#| RStudio-View: Showcase

ui <- fluidPage(
  numericInput("n", "n", 0)
)
server <- function(input, output, session) {
  observeEvent(input$n, {
    # # üí• ¬°BUCLE INFINITO! Cambiar input$n dispara este mismo observeEvent
    updateNumericInput(session, inputId = "n", value = input$n + 1) 
  })
}

# üßö‚Äç‚ôÄÔ∏è NUNCA ejecutar esto... 

# üòà Nah... podemos probar, localmente no es grave

shinyApp(ui, server) #<- üö®  
```




::: notes
As√≠ como la UI din√°mica es poderosa, tambi√©n viene con advertencias importantes. Una de las m√°s cr√≠ticas es el riesgo de **referencias circulares** o bucles infinitos.

Esto ocurre cuando un `observeEvent` reacciona a un input, y la acci√≥n dentro de ese `observeEvent` es *actualizar el valor de ese mismo input*.

Aqu√≠ tienen un ejemplo trivial, pero que ilustra el problema perfectamente. Tenemos un `numericInput` llamado `n`. En el servidor, hay un `observeEvent` que escucha a `input$n`. Cuando `input$n` cambia, este observador se activa. Y lo que hace dentro es llamar a `updateNumericInput()` para incrementar el valor de `n` en 1.

¬øQu√© pasa entonces? `updateNumericInput` cambia `input$n`. Un cambio en `input$n` **vuelve a disparar** el mismo `observeEvent`. Este a su vez vuelve a incrementar `input$n`, lo que lo vuelve a disparar, y as√≠ hasta el infinito. La aplicaci√≥n se bloquea, consume toda la CPU y la memoria. ¬°No podemos ni intentar ejecutar esto!
:::

------------------------------------------------------------------------

### üíÄ Lo que Pasa:

1.  `input$n` cambia ‚Üí `observeEvent` se dispara
2.  `updateNumericInput` cambia `input$n`
3.  `input$n` cambi√≥ ‚Üí `observeEvent` se dispara
4.  `updateNumericInput` cambia `input$n`
5.  **¬°HASTA EL INFINITO!** üîÑüí•

::: notes
Es crucial ser consciente de c√≥mo sus reactivos se conectan entre s√≠ para evitar este tipo de bucles. No se nos va a pasar en un un loop de un solo elemenento... pero es posible con m√°s.
:::

------------------------------------------------------------------------

### üîóüß© Inputs Interrelacionados {.smaller}

**Problema:** M√∫ltiples inputs representan la misma "verdad" subyacente (ej: Temperatura en ¬∞C y ¬∞F). Actualizar uno basado en el otro puede llevar a reptir los ciclos.

```{r temperature-app, eval=FALSE}
#| code-line-numbers: "|8-13|15-20"
#| echo: true
#| RStudio-View: Showcase

ui <- fluidPage(
  numericInput("temp_c", "Celsius", NA, step = 1),
  numericInput("temp_f", "Fahrenheit", NA, step = 1)
)

server <- function(input, output, session) {
  
  # üîÑ F ‚Üí C  Actualiza Celsius si Fahrenheit cambia
  observeEvent(input$temp_f, {
    # req(input$temp_f) # Buena idea a√±adir req()
    c <- round((input$temp_f - 32) * 5 / 9)
    updateNumericInput(session, inputId = "temp_c", value = c)
  })
  
  # üîÑ C ‚Üí F : Actualiza Fahrenheit si Celsius cambia
  observeEvent(input$temp_c, {
    # req(input$temp_c) # Buena idea a√±adir req()
    f <- round((input$temp_c * 9 / 5) + 32)
    updateNumericInput(session, inputId = "temp_f", value = f)
  })
}
shinyApp(ui, server)
```

::: notes
Relacionado con las referencias circulares, pero con un matiz diferente, tenemos el caso de **inputs interrelacionados**.

Aqu√≠, dos o m√°s inputs representan la misma informaci√≥n subyacente, pero en diferentes formatos. El ejemplo cl√°sico es la conversi√≥n entre Celsius y Fahrenheit. Si el usuario introduce un valor en Celsius, queremos que el Fahrenheit se actualice autom√°ticamente, y viceversa.

En este c√≥digo, tenemos dos `numericInput`: `temp_c` y `temp_f`. Tenemos un `observeEvent` (l√≠neas 9-13) que actualiza `temp_c` cuando `temp_f` cambia. Y otro `observeEvent` (l√≠neas 16-19) que actualiza `temp_f` cuando `temp_c` cambia.

A primera vista, esto parece un bucle infinito, ¬øverdad? Y lo ser√≠a si no fuera por las reglas de reactividad de Shiny. Shiny es lo suficientemente inteligente como para detectar que un valor ha sido program√°ticamente actualizado y a veces "suprime" disparadores reactivos si el valor no ha cambiado realmente o si se alcanza un estado de equilibrio.

Sin embargo, el comportamiento puede ser impredecible, a veces causando "rebotes" (ej: F=120 -\> C=48.8 -\> F=119.9). Dependiendo de los redondeos o de las operaciones, podr√≠as ver c√≥mo los valores "rebotan" entre s√≠ un par de veces antes de estabilizarse, o incluso generar ciclos si no hay convergencia.

La regla de oro para evitar estos problemas es simple: siempre que escriban un `updateInput`, preg√∫ntense: "¬øEste cambio puede disparar el mismo observeEvent que lo est√° causando?" Si la respuesta es s√≠, probablemente necesiten repensar su arquitectura.
:::

------------------------------------------------------------------------

### üîóüß© Rebote de valores (en realidad se saltea un impar)

**Resultado:** Valores "rebotando" hasta estabilizarse (¬°si es que lo hacen!) üèì " (ej: F=120 -\> F=119 -\> C=48 -\> F=118) hasta que se alcanza un equilibrio (si lo hay). **Recomendaci√≥n:** Evitar si es posible, o analizar cuidadosamente la convergencia.

![](img/rebote_valores_120.jpg){width="30%"} ![](img/rebote_valores_118.jpg){width="30%"}

::: {.fragment .fade-in}
### üõ°Ô∏è **Defensa:** Siempre preg√∫ntate: "¬øEste update puede disparar el mismo observeEvent?"
:::

::: notes

Sin embargo, el comportamiento puede ser impredecible, a veces causando "rebotes" (ej: F=120 -\> C=48.8 -\> F=119.9). Dependiendo de los redondeos o de las operaciones, podr√≠as ver c√≥mo los valores "rebotan" entre s√≠ un par de veces antes de estabilizarse, o incluso generar ciclos si no hay convergencia.

La regla de oro para evitar estos problemas es simple: siempre que escriban un `updateInput`, preg√∫ntense: "¬øEste cambio puede disparar el mismo observeEvent que lo est√° causando?" Si la respuesta es s√≠, probablemente necesiten repensar su arquitectura.

:::

------------------------------------------------------------------------

### üë©‚Äçüíª/üë®‚Äçüíª Ejercicios (Secci√≥n 10.1)

10.1.6.1.  **Fechas por A√±o:** `numericInput("year")`, `dateInput("date")`. Actualiza `min` y `max` de `input$date` basado en `input$year`.

```{r, eval=FALSE}
# 10.1.6 Exercises (1)
# Complete the user interface below with a server function that updates input$date
# so that you can only select dates in input$year.

# c√≥digo de la propuesta:
library(shiny)

ui <- fluidPage(
    numericInput("year", "year", value = 2020),
    dateInput("date", "date")
)

# completar con c√≥digo debajo:
server <- function(input, output, server){
    observeEvent(
        input$year,
        updateDateInput(
            inputId = "date",
            # min = lubridate::make_date(input$year,1,1),
            min = as.Date(paste(input$year, "01", "01", sep = "-")),
            # max = lubridate::make_date(input$year,12,31),
            max = as.Date(paste(input$year, "12", "31", sep = "-")),
            value = lubridate::make_date(input$year,1,1)
        )
    )
}

shinyApp(ui, server)
```

::: notes

Usamos observeEvent(input$year, {updateDateInput()}) para actualizar el rango (m√≠nimo y m√°ximo) y el value (el valor inicial que nos muestra)

:::


------------------------------------------------------------------------

10.1.6.2.  **Estado/Condado:** `selectInput("state")`, `selectInput("county", choices = NULL)`. Actualiza `choices` y `label` de `input$county` basado en `input$state` (usando `openintro::county`).

```{r, eval=FALSE}
# 10.1.6 Exercises (2) con condiciones

# Complete the user interface below with a server function that updates 
# input$county choices based on input$state. For an added challenge, also change 
# the label from "County" to "Parish" for Louisiana and "Borough" for Alaska.

# agrego porque no es un paquete que crea usual
if(!require(openintro, quietly = TRUE)){install.packages("openintro");library(openintro, warn.conflicts = FALSE)}

library(openintro, warn.conflicts = FALSE)
#> Loading required package: airports
#> Loading required package: cherryblossom
#> Loading required package: usdata
#> Registered S3 methods overwritten by 'readr':
#>   method                    from 
#>   as.data.frame.spec_tbl_df vroom
#>   as_tibble.spec_tbl_df     vroom
#>   format.col_spec           vroom
#>   print.col_spec            vroom
#>   print.collector           vroom
#>   print.date_names          vroom
#>   print.locale              vroom
#>   str.col_spec              vroom

library(shiny)

states <- unique(county$state)

ui <- fluidPage(
    selectInput("state", "State", choices = states),
    selectInput("county", "County", choices = NULL)
)

server <- function(input,output, server){
    counties <- reactive({
        unique(county[,c("state","name") ]) %>%
            filter(state %in% input$state) %>% 
            pull(name)
    })
    
    observeEvent(input$state,{
        if(input$state == "Louisiana"){
            updateSelectInput(
                session= getDefaultReactiveDomain(),
                inputId = "county",
                label = "Parish",
                choices = counties())
        }else if(input$state == "Alaska"){
            updateSelectInput(
                session= getDefaultReactiveDomain(),
                inputId = "county",
                label = "Borough",
                choices = counties())
        }else{
            # Other states
            updateSelectInput(
                session= getDefaultReactiveDomain(),
                inputId = "county",
                # (!!!) 
                # Hay que recordar volver a "County" despu√©s de visitar Alaska
                # y Louisiana
                label = "County",
                choices = counties())    
        }
    })
}

shinyApp(ui, server)

# versi√≥n m√°s elegante:
server <- function(input, output, session) {
    # Actualizar las opciones de "county" seg√∫n el "state" seleccionado
    observeEvent(input$state, {
        # Filtrar los condados asociados al estado seleccionado
        counties <- unique(county[county$state == input$state, "name"])
        
        # üë©‚Äçüéì Cambiar din√°micamente la etiqueta seg√∫n el estado
        label <- switch(input$state,
                        "Louisiana" = "Parish",
                        "Alaska" = "Borough",
                        "County")
        
        # Actualizar las opciones y etiqueta del selectInput para "county"
        updateSelectInput(session, inputId = "county",
                          label = label,
                          choices = counties)
    })
}

```

:::notes

M√°s abajo uso un switch, que tomando una clave de tipo num√©rico o character
devuelve el valor asociado a esa clave.

:::


------------------------------------------------------------------------

10.1.6.3.  **Continente/Pa√≠s:** `selectInput("continent")`, `selectInput("country", choices = NULL)`. Actualiza `choices` de `input$country` basado en `input$continent` (usando `gapminder::gapminder`).

```{r, eval=FALSE}
# 10.1.6 Exercises (3)

# Complete the user interface below with a server function that 
# updates input$country choices based on the input$continent. 
# Use output$data to display all matching rows.

library(shiny)
library(gapminder)
continents <- unique(gapminder$continent)

ui <- fluidPage(
    selectInput("continent", "Continent", choices = continents), 
    selectInput("country", "Country", choices = NULL),           
    tableOutput("data")
)

server <- function(input, output, server){
    
    choices <- reactive({
        # es igual que gapminder %>% filter(continent == input$continent) %>% distinct(country)
        unique(gapminder[gapminder$continent==input$continent,"country"])
    })
        
    observeEvent(input$continent, {
        updateSelectInput(
            session = getDefaultReactiveDomain(),# valor por defecto
            inputId = "country",
            choices = choices()
        )
    })
    
    output$data <- renderTable(
        # tabla filtrada, todas las columnas
        gapminder[gapminder$country==input$country,]
    )
}
shinyApp(ui, server)


```

:::notes

El ejercicio nos da el UI y hacemos server(). Primero hacemos el reactive choices()
con los pa√≠ses del continente que traemos del objeto input.
Luego ante cambios en input$continent actualizamos el selectInput("country") con 
ese mismo reactive.
El output$data recibe la tabla filtrada (sea con un vector l√≥gico y subsetting de base o con dplyr)

:::


------------------------------------------------------------------------

10.1.6.4.  **Extensi√≥n:** A√±adir "(Todos)" a continentes/pa√≠ses.


```{r, eval=FALSE}
# 10.1.6 Exercises (4)

# Extend the previous app so that you can also choose to select all continents, 
# and hence see all countries. You‚Äôll need to add "(All)" to the list of choices, 
# and then handle that specially when filtering.

library(shiny)
library(gapminder)

# Agrego "(All)" y tuve que forzar a que tomara los valores...
# tambi√©n podr√≠a haber usado unique(as.character(gapminder$continent))
continents <- c("(All)", levels(gapminder$continent))

ui <- fluidPage(
    selectInput("continent", "Continent", choices = continents),
    selectInput("country", "Country", choices = NULL),
    tableOutput("data")
)

server <- function(input, output, server){
    
    choices <- reactive({
        if(input$continent == "(All)"){
            unique(gapminder$country)
        }else{
            unique(gapminder[gapminder$continent==input$continent,"country"])
        }
    })
    
    observeEvent(input$continent,
                 {
                     updateSelectInput(
                         session = getDefaultReactiveDomain(),
                         inputId = "country",
                         choices = choices()
                     )
                 })
    output$data <- renderTable(
        gapminder[gapminder$country==input$country,]
    )
}
shinyApp(ui, server)

```

:::notes

Agregamos la opci√≥n ALL al vector continents y una estructura if-else donde 
en la llamada a unique() no exclu√≠mos ning√∫n pa√≠s.

:::


------------------------------------------------------------------------

10.1.6.5.  **Debug:** Analizar el problema en el link de RStudio Community (requiere acceso externo).

El problema central descrito en el enlace mencionado (https://community.rstudio.com/t/29307) 
se relaciona con la gesti√≥n de referencias circulares en aplicaciones Shiny. 
Seg√∫n el contenido del libro, este tipo de problema surge cuando se utilizan funciones de
actualizaci√≥n (updateNumericInput, por ejemplo) para modificar valores de
entrada que, a su vez, desencadenan eventos reactivos que vuelven a modificar
el mismo valor. Esto puede generar bucles infinitos y comportamientos
inesperados en la aplicaci√≥n.

Hadley explica que, desde la perspectiva de Shiny, las actualizaciones
program√°ticas de un valor son tratadas de la misma manera que las
modificaciones realizadas por el usuario. Esto significa que cualquier cambio
en un valor de entrada puede activar observadores reactivos, lo que puede
llevar a ciclos de actualizaci√≥n interminables si no se manejan adecuadamente
las dependencias entre los controles.

Para evitar estos problemas, se recomienda utilizar herramientas como
isolate() para romper la dependencia reactiva o implementar l√≥gica condicional
que limite las actualizaciones.

```{r}
library(shiny)
ui <- shinyUI(fluidPage(
  titlePanel("Mutually Dependent Input Values"),
  sidebarLayout(
    sidebarPanel(
      numericInput("A", "A",.333),
      numericInput("B", "B",.333),
      numericInput("C", "C",.333)
    ),
    mainPanel(
      verbatimTextOutput("result")
    )
  )
)) 

server <- shinyServer(function(input, output,session) {

    
    observeEvent(input$A, {
        newB <- isolate(1 - input$A - input$C)
        updateNumericInput(session, "B", value = newB)
        newC <- 1 - isolate(input$A - input$B)
        updateNumericInput(session, "C", value = newC)
    })
    observeEvent(input$B, {
        newC <- 1 - input$B - input$A
        updateNumericInput(session, "C", value = newC)
        newA <- 1 - input$B - input$C
        updateNumericInput(session, "A", value = newA)
    })
    observeEvent(input$C, {
        newA <- 1 - input$C - input$B
        updateNumericInput(session, "A", value = newA)
        newB <- 1 - input$C - input$C
        updateNumericInput(session, "B", value = newB)
    })
    
})
shinyApp(ui,server)

```


------------------------------------------------------------------------

## üÉè Siguiente caso... no siempre queremos mostrar todo ‚ò¢

![](img/vasos_transparentes.jpg){width="50%"}

:::notes
No es realmente an√°logo... pero bueno... vamos a controlar la visibilidad de nuestros contenedores.
:::

------------------------------------------------------------------------

## 2. üëª Visibilidad Din√°mica üîÑ (`tabsetPanel` oculto)

**üéØ Objetivo:** Mostrar/ocultar partes de la UI sin recrearlas.

**‚öôÔ∏è T√©cnica (Hack):**

1.  Usar `tabsetPanel(id = "switcher", type = "hidden", ...)` para contener diferentes secciones de UI en `tabPanelBody()` o `tabPanel()`.

2.  Usar `updateTabsetPanel(inputId = "switcher", selected = "panel_id")` desde el servidor para cambiar qu√© panel est√° visible.

> üí° **Concepto clave:** Separaci√≥n entre estructura y presentaci√≥n - los elementos existen en DOM pero se controla su visibilidad

:::notes
Pasemos a la segunda t√©cnica para la UI din√°mica: la **Visibilidad Din√°mica**, que se logra de una manera un poco ingeniosa con `tabsetPanel()`.

El objetivo aqu√≠ es simplemente mostrar u ocultar grandes bloques de UI de forma condicional. No se trata de cambiar propiedades de un input existente, sino de hacer aparecer o desaparecer secciones enteras.

La "t√©cnica" o "hack" es la siguiente: 1. Creamos un `tabsetPanel`. Normalmente, un `tabsetPanel` muestra pesta√±as en la parte superior para que el usuario pueda hacer clic y cambiar de panel. Pero si le pasamos el argumento `type = "hidden"`, esas pesta√±as desaparecen. El `tabsetPanel` act√∫a entonces como un contenedor invisible para diferentes paneles (`tabPanelBody` o `tabPanel`).

2.  Desde el servidor, usamos `updateTabsetPanel()` para decirle al `tabsetPanel` cu√°l de sus paneles internos (`selected = "panel_id"`) debe mostrarse. Los otros paneles, aunque presentes en el HTML, estar√°n ocultos.

Esto es muy eficiente porque los paneles no se recrean cada vez que cambian; simplemente se conmutan su visibilidad.
:::

------------------------------------------------------------------------

### üóÇ üîΩ üìë Ejemplo B√°sico: Cambiador de Paneles

```{r dynamic-visibility-basic-app, eval=FALSE}
#| code-line-numbers: "|9|10-13|18-22"
#| echo: true
#| RStudio-View: Showcase

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      selectInput("controller", "Show", choices = paste0("panel", 1:3))
    ),
    mainPanel(
      tabsetPanel(
        id = "switcher",  # ID para referenciarlo
        type = "hidden",  # ¬°Oculta las pesta√±as!
        tabPanelBody("panel1", "Panel 1 content"),
        tabPanelBody("panel2", "Panel 2 content"),
        tabPanelBody("panel3", "Panel 3 content")
      )
    )
  )
)

server <- function(input, output, session) {
  observeEvent(input$controller, {
    updateTabsetPanel(session, inputId = "switcher", selected = input$controller)
  })
}
shinyApp(ui, server)
```

> üìä **Ventaja t√©cnica:** Transiciones instant√°neas sin overhead (costo computacional) de renderizado (de generar y dibujar los elementos en la pantalla) al cambiar de tabPanelBody()

::: notes
Veamos un ejemplo sencillo de c√≥mo funciona este "cambiador de paneles" oculto.

En la UI, tenemos un `sidebarLayout`. En el `sidebarPanel`, un `selectInput` llamado "controller" con opciones "panel1", "panel2", "panel3". Este ser√° nuestro control para cambiar el contenido.

En el `mainPanel`, definimos nuestro `tabsetPanel` (l√≠nea 9). Le damos un `id` ("switcher") para poder referenciarlo desde el servidor, y lo m√°s importante, le pasamos `type = "hidden"` (l√≠nea 10) para que no muestre las pesta√±as. Dentro, definimos tres `tabPanelBody` (o `tabPanel`) con IDs "panel1", "panel2", "panel3" y algo de contenido.

En el servidor (l√≠nea 19), tenemos un `observeEvent` que reacciona a los cambios en `input$controller`. Cuando el usuario selecciona una opci√≥n, llamamos a `updateTabsetPanel()`. Le pasamos el `session`, el `inputId` de nuestro `tabsetPanel` oculto (que es "switcher"), y el `selected` panel debe ser el valor actual de `input$controller`.

Si ejecutan esta aplicaci√≥n, ver√°n que al cambiar la opci√≥n en el selector, el contenido del panel principal cambia instant√°neamente, sin que aparezcan las pesta√±as. Es una forma muy limpia de hacer condicional una parte de la UI.
:::

------------------------------------------------------------------------

###  üìù Caso de Uso: UI Condicional (Par√°metros de una distribuci√≥n)

**üìã Objetivo:** Mostrar diferentes controles de par√°metros seg√∫n la distribuci√≥n seleccionada (Normal, Uniforme, Exponencial).

**üîß Implementaci√≥n:** - Cada conjunto de par√°metros en un `tabPanel` dentro de un `tabsetPanel` oculto. - El `selectInput("dist")` controla qu√© `tabPanel` se muestra v√≠a `updateTabsetPanel`.

![](img/caso_de_uso_ui_condicional.jpg){width="50%"}

::: notes
Un caso de uso cl√°sico para la visibilidad din√°mica es la **UI Condicional** donde los controles de entrada cambian seg√∫n una elecci√≥n previa. Aqu√≠, queremos mostrar diferentes par√°metros de distribuci√≥n (media/desviaci√≥n est√°ndar para Normal, min/max para Uniforme, tasa para Exponencial) bas√°ndose en la distribuci√≥n seleccionada por el usuario.
:::

------------------------------------------------------------------------

###  üìù Caso de Uso: UI Condicional (Par√°metros de una distribuci√≥n)

```{r conditional-ui-app, eval=FALSE}
#| echo: true
#| RStudio-View: Showcase
#| code-line-numbers: "1-58|2-4|4,5,9,13|4,5,6,7,9,10,11,13,14|21-25|35-39|41-50|52-56"

# UI para los par√°metros espec√≠ficos
parameter_tabs <- tabsetPanel(
  id = "params", # ID para controlar desde el server
  type = "hidden", # Oculto
  tabPanel("normal",
           numericInput("mean", "mean", value = 1),
           numericInput("sd", "standard deviation", min = 0, value = 1)
  ),
  tabPanel("uniform",
           numericInput("min", "min", value = 0),
           numericInput("max", "max", value = 1)
  ),
  tabPanel("exponential",
           numericInput("rate", "rate", value = 1, min = 0),
  )
)

# UI completa
ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      selectInput("dist", "Distribution",
                  choices = c("normal", "uniform", "exponential") # Coinciden con nombres de tabPanel
      ),
      numericInput("n", "Number of samples", value = 100),
      parameter_tabs # Incrusta el tabset oculto
    ),
    mainPanel(
      plotOutput("hist")
    )
  )
)

# Server
server <- function(input, output, session) {
  # Cambia el panel de par√°metros visible cuando cambia la distribuci√≥n
  observeEvent(input$dist, {
    updateTabsetPanel(session, inputId = "params", selected = input$dist)
  })
  
  # Genera la muestra basada en la distribuci√≥n y par√°metros seleccionados
  sample <- reactive({
    # ¬°Importante! Los inputs (ej: input$mean) existen aunque no sean visibles
    req(input$dist) # Asegura que hay una selecci√≥n
    switch(input$dist,
           normal = rnorm(input$n, input$mean, input$sd),
           uniform = runif(input$n, input$min, input$max),
           exponential = rexp(input$n, input$rate)
    )
  })
  
  # Dibuja el histograma
  output$hist <- renderPlot({
    hist(sample())
  }, res = 96)
}

shinyApp(ui, server)
```

::: notes
[‚ñ∂]{style="color: #FF0000;"} Primero, definimos un `tabsetPanel` oculto (`id = "params", type = "hidden"`) [‚ñ∂]{style="color: #FF0000;"} que contiene tres `tabPanel` (uno para cada distribuci√≥n), y cada `tabPanel` contiene [‚ñ∂]{style="color: #FF0000;"}los `numericInput` espec√≠ficos para esa distribuci√≥n. Es importante que los IDs de los `tabPanel` (ej: "normal", "uniform", "exponential") coincidan con los `choices` de nuestro `selectInput` principal.

Luego, en nuestra UI principal, [‚ñ∂]{style="color: #FF0000;"} simplemente incluimos este `parameter_tabs` oculto. [‚ñ∂]{style="color: #FF0000;"} Tenemos un `selectInput` para elegir la distribuci√≥n (`input$dist`), y un `numericInput` para el n√∫mero de muestras.

En el servidor, [‚ñ∂]{style="color: #FF0000;"} un `observeEvent` reacciona a los cambios en `input$dist`. Este observador llama a `updateTabsetPanel()` para nuestro `tabsetPanel` oculto (`params`), estableciendo el panel `selected` al nombre de la distribuci√≥n elegida.

Un punto *muy importante* aqu√≠ es que, aunque los inputs de los paneles ocultos no sean visibles, *sus valores siguen existiendo* en `input$mean`, `input$sd`, etc. Esto significa que podemos acceder a ellos en nuestro reactivo `sample()` sin problemas. [‚ñ∂]{style="color: #FF0000;"} El `switch` statement es perfecto aqu√≠ para generar la muestra correcta basada en la distribuci√≥n y sus par√°metros.

Finalmente, el `renderPlot` simplemente visualiza el histograma de la muestra generada. Este es un patr√≥n muy com√∫n para UIs condicionales.
:::

------------------------------------------------------------------------

###  üìù Caso de Uso: Interfaz de Asistente (Wizard üßô)

**üéØ Objetivo:** Guiar al usuario a trav√©s de un proceso multi-paso.

**C√≥mo ü§î:**

-   Cada paso es un `tabPanel` dentro de un `tabsetPanel` oculto.
-   Botones "Anterior"/"Siguiente" (`actionButton`) en cada panel. 
-   `observeEvent` en los botones llaman a `updateTabsetPanel` para cambiar de p√°gina (`selected = "page_i"`).

```{r wizard-app, eval=FALSE}
#| echo: true
#| RStudio-View: Showcase
#| code-line-numbers: "false"

ui <- fluidPage(
  tabsetPanel(
    id = "wizard", # ID del tabset
    type = "hidden", # Oculto
    tabPanel("page_1", # Valor para 'selected'
             "Welcome!",
             actionButton("page_12", "next") # Bot√≥n para ir a p√°gina 2
    ),
    tabPanel("page_2", 
             "Only one page to go",
             actionButton("page_21", "prev"), # Bot√≥n para ir a p√°gina 1
             actionButton("page_23", "next")  # Bot√≥n para ir a p√°gina 3
    ),
    tabPanel("page_3",
             "You're done!",
             actionButton("page_32", "prev") # Bot√≥n para ir a p√°gina 2
    )
  )
)

server <- function(input, output, session) {
  # Funci√≥n helper para cambiar de p√°gina
  switch_page <- function(i) {
    updateTabsetPanel(session, inputId = "wizard", selected = paste0("page_", i))
  }
  
  # Observadores para cada bot√≥n
  observeEvent(input$page_12, switch_page(2))
  observeEvent(input$page_21, switch_page(1))
  observeEvent(input$page_23, switch_page(3))
  observeEvent(input$page_32, switch_page(2))
}

shinyApp(ui, server)
```

::: notes
Un √∫ltimo caso de uso muy com√∫n para los `tabsetPanel` ocultos es la creaci√≥n de interfaces de **Asistente** o "Wizard".

El objetivo es guiar al usuario a trav√©s de un proceso que tiene m√∫ltiples pasos, donde cada paso es una "p√°gina" y el usuario navega secuencialmente con botones "Siguiente" y "Anterior".

La estructura es muy similar a la anterior: Tenemos un `tabsetPanel` con `id = "wizard"` y `type = "hidden"`. Dentro, cada paso del asistente es un `tabPanel` con un `id` √∫nico (ej: "page_1", "page_2", "page_3").

Dentro de cada `tabPanel`, en lugar de controles de entrada condicionales, colocamos `actionButton`s para la navegaci√≥n. Por ejemplo, en "page_1" tenemos un bot√≥n `page_12` para ir a la p√°gina 2. En "page_2", tenemos botones `page_21` y `page_23` para ir a la p√°gina 1 y 3 respectivamente.

En el servidor, definimos una funci√≥n `switch_page()` de ayuda que toma un n√∫mero de p√°gina y llama a `updateTabsetPanel()` para nuestro `wizard` para seleccionar la p√°gina correspondiente. Luego, simplemente creamos un `observeEvent` para cada bot√≥n de navegaci√≥n, llamando a `switch_page()` con el n√∫mero de la p√°gina a la que queremos ir.

Esto crea una experiencia de usuario fluida y guiada, ideal para flujos de trabajo complejos o para recopilar informaci√≥n paso a paso.
:::

------------------------------------------------------------------------

###  üìù Caso de Uso: Interfaz de Flujo Secuencial

**üìà Contexto:** Proceso de an√°lisis de datos con validaci√≥n por etapas **üîÑ Implementaci√≥n:** Navegaci√≥n controlada con validaci√≥n progresiva

> üîí **Patr√≥n avanzado:** Validaci√≥n progresiva con `reactiveValues` para gesti√≥n de estado complejo

```{r wizard-app-2, eval=FALSE}
#| echo: true
#| RStudio-View: Showcase
#| code-line-numbers: "false"

ui <- fluidPage(
  titlePanel("Asistente de An√°lisis de Datos"),
  
  tabsetPanel(
    id = "wizard",
    type = "hidden",
    
    # Etapa 1: Carga de datos
    tabPanel("step_1",
             fluidRow(
               column(12,
                      h3("üìÅ Paso 1: Carga de Datos"),
                      fileInput("file", "Seleccionar archivo CSV",
                               accept = c(".csv")),
                      conditionalPanel(
                        condition = "output.file_uploaded",
                        h4("Vista previa:"),
                        DT::dataTableOutput("preview")
                      ),
                      br(),
                      div(style = "text-align: right;",
                          actionButton("step1_next", "Continuar ‚Üí", 
                                     class = "btn-primary"))
               )
             )
    ),
    
    # Etapa 2: Configuraci√≥n de an√°lisis
    tabPanel("step_2",
             fluidRow(
               column(12,
                      h3("‚öôÔ∏è Paso 2: Configuraci√≥n del An√°lisis"),
                      selectInput("response_var", "Variable dependiente:", 
                                choices = NULL),
                      checkboxGroupInput("predictor_vars", "Variables predictoras:",
                                       choices = NULL),
                      radioButtons("analysis_type", "Tipo de an√°lisis:",
                                 choices = c("Regresi√≥n lineal" = "lm",
                                           "Regresi√≥n log√≠stica" = "glm",
                                           "An√°lisis de varianza" = "aov")),
                      br(),
                      div(style = "text-align: right;",
                          actionButton("step2_prev", "‚Üê Anterior", 
                                     class = "btn-secondary"),
                          actionButton("step2_next", "Continuar ‚Üí", 
                                     class = "btn-primary"))
               )
             )
    ),
    
    # Etapa 3: Resultados
    tabPanel("step_3",
             fluidRow(
               column(12,
                      h3("üìä Paso 3: Resultados del An√°lisis"),
                      verbatimTextOutput("analysis_results"),
                      plotOutput("analysis_plot"),
                      br(),
                      div(style = "text-align: right;",
                          actionButton("step3_prev", "‚Üê Anterior", 
                                     class = "btn-secondary"),
                          downloadButton("download_report", "Descargar Reporte",
                                       class = "btn-success"))
               )
             )
    )
  )
)

server <- function(input, output, session) {
  # Almacenamiento reactivo de datos
  values <- reactiveValues(
    data = NULL,
    current_step = 1
  )
  
  # Control de navegaci√≥n con validaci√≥n
  navigate_to_step <- function(step) {
    updateTabsetPanel(session, inputId = "wizard", selected = paste0("step_", step))
    values$current_step <- step
  }
  
  # Validaciones por etapa
  validate_step1 <- reactive({
    !is.null(values$data) && nrow(values$data) > 0
  })
  
  validate_step2 <- reactive({
    !is.null(input$response_var) && 
    !is.null(input$predictor_vars) && 
    length(input$predictor_vars) > 0
  })
  
  # Carga y procesamiento de datos
  observeEvent(input$file, {
    req(input$file)
    values$data <- read.csv(input$file$datapath)
    
    # Actualizar opciones de variables
    updateSelectInput(session, "response_var", 
                     choices = names(values$data))
    updateCheckboxGroupInput(session, "predictor_vars", 
                           choices = names(values$data))
  })
  
  # Navegaci√≥n entre pasos
  observeEvent(input$step1_next, {
    if (validate_step1()) {
      navigate_to_step(2)
    } else {
      showNotification("Por favor, cargue un archivo v√°lido", type = "warning")
    }
  })
  
  observeEvent(input$step2_prev, navigate_to_step(1))
  observeEvent(input$step2_next, {
    if (validate_step2()) {
      navigate_to_step(3)
    } else {
      showNotification("Por favor, configure todas las variables", type = "warning")
    }
  })
  
  observeEvent(input$step3_prev, navigate_to_step(2))
  
  # Outputs
  output$file_uploaded <- reactive({
    !is.null(values$data)
  })
  outputOptions(output, "file_uploaded", suspendWhenHidden = FALSE)
  
  output$preview <- DT::renderDataTable({
    req(values$data)
    DT::datatable(head(values$data, 100), options = list(scrollX = TRUE))
  })
  
  output$analysis_results <- renderText({
    req(validate_step2(), values$data)
    
    formula_str <- paste(input$response_var, "~", 
                        paste(input$predictor_vars, collapse = " + "))
    
    model <- switch(input$analysis_type,
                   "lm" = lm(as.formula(formula_str), data = values$data),
                   "glm" = glm(as.formula(formula_str), data = values$data),
                   "aov" = aov(as.formula(formula_str), data = values$data))
    
    capture.output(summary(model))
  })
}

shinyApp(ui, server)
```

::: notes
Este ejemplo demuestra c√≥mo implementar un flujo de trabajo secuencial con validaci√≥n en cada etapa. Es un patr√≥n com√∫n en aplicaciones de an√°lisis de datos donde se requiere una progresi√≥n l√≥gica y validada.

La arquitectura utiliza `reactiveValues` para mantener el estado global de la aplicaci√≥n, incluyendo los datos cargados y el paso actual. Esto permite un control m√°s sofisticado que las variables reactivas simples.

Las funciones de validaci√≥n (`validate_step1`, `validate_step2`) aseguran que el usuario no pueda avanzar sin completar correctamente cada etapa. Esto es crucial en aplicaciones profesionales donde la integridad del proceso es fundamental.

El patr√≥n de navegaci√≥n controlada (`navigate_to_step`) centraliza la l√≥gica de cambio de estado, facilitando el mantenimiento y la extensibilidad. Agregar nuevos pasos requiere principalmente extender esta funci√≥n y a√±adir las validaciones correspondientes.

Esta implementaci√≥n es especialmente valiosa en contextos donde se requiere documentar el proceso de an√°lisis o donde m√∫ltiples usuarios pueden necesitar seguir protocolos estandarizados.
:::

------------------------------------------------------------------------

### üìà Consideraciones T√©cnicas y Mejores Pr√°cticas (1)

**‚úÖ Ventajas del Patr√≥n:**

\- **Rendimiento optimizado:** Sin reconstrucci√≥n de elementos DOM

\- **Consistencia de estado:** Los valores de inputs se mantienen entre transiciones

\- **Experiencia fluida:** Transiciones instant√°neas sin efectos de carga

\- **Arquitectura escalable:** F√°cil expansi√≥n y mantenimiento modular

::: notes

Para concluir esta secci√≥n, es importante entender que la visibilidad din√°mica no es simplemente un truco t√©cnico, sino una herramienta fundamental para crear aplicaciones Shiny de nivel profesional.

En el contexto empresarial y acad√©mico, este patr√≥n resuelve problemas reales: interfaces que deben adaptarse a diferentes tipos de usuarios, flujos de trabajo complejos que requieren validaci√≥n, y aplicaciones de an√°lisis donde el rendimiento es cr√≠tico.

:::

------------------------------------------------------------------------

### üìà Consideraciones T√©cnicas y Mejores Pr√°cticas (2)

**‚ö†Ô∏è Consideraciones de Implementaci√≥n:**

\- **Correspondencia de IDs:** Sincronizaci√≥n exacta entre controladores y paneles

\- **Gesti√≥n de memoria:** Los inputs ocultos consumen recursos aunque no sean visibles

\- **Validaci√≥n de estado:** Verificaci√≥n de valores antes de transiciones cr√≠ticas

\- **Accesibilidad:** Considerar usuarios con tecnolog√≠as asistivas

::: notes

Las consideraciones de memoria son particularmente importantes en aplicaciones de gran escala. Aunque los inputs ocultos mantienen sus valores, tambi√©n consumen recursos. En aplicaciones con muchos paneles condicionales, es importante evaluar si este patr√≥n es la soluci√≥n m√°s eficiente.

:::

------------------------------------------------------------------------

## üîß Optimizaciones Recomendadas: 

-   Usar `req()` para validaci√≥n robusta de inputs
-   Implementar `showNotification()` para feedback contextual
-   Considerar `conditionalPanel()` para casos simples 
-   Documentar la l√≥gica de estado para facilitar mantenimiento

> üí° **Insight profesional:** Este patr√≥n es especialmente valioso en dashboards empresariales y aplicaciones de an√°lisis donde la experiencia del usuario y el rendimiento son prioritarios.

::: notes

La accesibilidad es otro aspecto cr√≠tico que a menudo se pasa por alto. Los usuarios con lectores de pantalla pueden tener dificultades para navegar interfaces que cambian din√°micamente sin se√±ales claras. La implementaci√≥n de `showNotification()` y `aria-labels` apropiados puede mejorar significativamente la experiencia.

Finalmente, este patr√≥n representa un principio m√°s amplio en el desarrollo de software: la separaci√≥n entre estructura y presentaci√≥n. Al mantener todos los elementos en el DOM y controlar solo su visibilidad, creamos aplicaciones m√°s robustas y mantenibles.

:::

------------------------------------------------------------------------

### üë©‚Äçüíª/üë®‚Äçüíª Ejercicios (Secci√≥n 10.2)

10.2.3 Exercises

1.  **Controles Avanzados:** Usar un `checkboxInput("advanced")` para mostrar/ocultar controles adicionales dentro de un `tabsetPanel` oculto.

"Use a hidden tabset to show additional controls only if the user checks an "advanced" check box."

```{r, eval=FALSE}
# 10.2.3 Exercises (1)
# Use a hidden tabset to show additional controls only if the user checks an
# "advanced" check box.

# probar con 2.718283 para que el log de 1

library(shiny)

ui <- fluidPage(
  sidebarLayout(
      sidebarPanel = sidebarPanel(
          numericInput("numero", "N√∫mero", value = 0, min = 0, max = 10, step = 1, width = "100px"),
          actionButton("advanced", "Advanced", icon = icon("cogs", lib = "font-awesome")),
          tabsetPanel(
              id = "tabsetPanel_advanced",
              type = "hidden",
              tabPanel(
                  title = "empty"
                  ),
              tabPanel(
                  title = "tabPanel_advanced",
                  hr(),
                  prettyCheckbox(
                      inputId = "logtransf",
                      label = "Transformaci√≥n logar√≠tmica",
                      icon = icon("check", lib = "font-awesome")
                  )
                  
              )
          )
      ),
      mainPanel = mainPanel(
          verbatimTextOutput(outputId = "resultado")
      )
  )
)

server <- function(input, output, session) {
    observeEvent(input$advanced,{
        if (is.null(input$tabsetPanel_advanced) || input$tabsetPanel_advanced == "empty") {
            updateTabsetPanel(session,
                              inputId = "tabsetPanel_advanced",
                              selected = "tabPanel_advanced")
        } else {
            updateTabsetPanel(session,
                              inputId = "tabsetPanel_advanced",
                              selected = "empty")
        }
        
    }
    )
    output$resultado <- renderText(
        if(input$logtransf == TRUE){
            log(input$numero)
        }else{
            input$numero
        }
    )
}


shinyApp(ui, server)
```

------------------------------------------------------------------------

2.  **Geoms de ggplot2:** Permitir elegir `geom_histogram`, `geom_freqpoly`, `geom_density`. Mostrar controles espec√≠ficos (`binwidth`, `bw`) usando `tabsetPanel` oculto seg√∫n el geom elegido.

Create an app that plots ggplot(diamonds, aes(carat)) but allows the user to choose which geom to use: geom_histogram(), geom_freqpoly(), or geom_density(). Use a hidden tabset to allow the user to select different arguments depending on the geom: geom_histogram() and geom_freqpoly() have a binwidth argument; geom_density() has a bw argument.

```{r, eval=FALSE}
# 10.2.3 Exercises (2)

# Crear una aplicaci√≥n que trace ggplot(diamonds, aes(carat)) pero que
# permita al usuario elegir qu√© geom usar: 
# geom_histogram(), geom_freqpoly(), o geom_density(). 

# Usar un tabset oculto para permitir al usuario seleccionar 
# diferentes argumentos dependiendo del geom: 
    # geom_histogram() y geom_freqpoly() tienen un argumento binwidth; 
    # geom_density() tiene un argumento bw.

library(shiny)
library(tidyverse)

ui <- fluidPage(
    sidebarLayout(
        sidebarPanel(
            selectInput(
                "geom_type",
                "Tipo de geom",
                choices = c("histogram", "freqpoly", "density"),
                selected = "histogram"
            ),
            tabsetPanel(
                id = "args",
                type = "hidden",
                tabPanel(
                    title = "histogram",
                    numericInput("binwidth", "Binwidth", value = 1, min = 0.1, max = 5, step = 0.1)
                ),
                tabPanel(
                    title = "freqpoly",
                    numericInput("binwidth", "Binwidth", value = 1, min = 0.1, max = 5, step = 0.1)
                ),
                tabPanel(
                    title = "density",
                    numericInput("bw", "Bandwidth", value = 1, min = 0.1, max = 5, step = 0.1)
                )
            )
        ),
        mainPanel(
            plotOutput("resultado")
        )
    )
)

server <- function(input, output, session) {
    
    observeEvent(input$geom_type, {
        updateTabsetPanel(session, "args", selected = input$geom_type)
    })
    
    output$resultado <- renderPlot({
        if (input$geom_type == "histogram") {
            ggplot(diamonds, aes(carat)) +
                geom_histogram(binwidth = input$binwidth)
        } else if (input$geom_type == "freqpoly") {
            ggplot(diamonds, aes(carat)) +
                geom_freqpoly(binwidth = input$binwidth)
        } else {
            ggplot(diamonds, aes(carat)) +
                geom_density(bw = input$bw)
        }
    })
}

shinyApp(ui, server)
```

------------------------------------------------------------------------

3.  **Extensi√≥n Geoms:** Permitir seleccionar *m√∫ltiples* geoms (0 a 3) y controlar sus par√°metros independientemente. (M√°s complejo, puede requerir `renderUI`).

Modify the app you created in the previous exercise to allow the user to choose whether each geom is shown or not (i.e. instead of always using one geom, they can picked 0, 1, 2, or 3). Make sure that you can control the binwidth of the histogram and frequency polygon independently.


```{r, eval=FALSE}
# 10.2.3 Exercises (3) v1

# Modifica la aplicaci√≥n que creaste en el ejercicio anterior para que el 
# usuario pueda elegir si se muestra o no cada geom (es decir, en lugar de 
# utilizar siempre un geom, puede elegir 0, 1, 2 o 3). Aseg√∫rate de que puedes
# controlar el binwidth del histograma y del pol√≠gono de frecuencias
# de forma independiente.

# Tomar esta soluci√≥n no es adecuado porque la escala de la densidad es otra
# Por eso la densidad queda "aplastada" contra las abscisas.

library(shiny)
library(ggplot2)

ui <- fluidPage(
    titlePanel("Gr√°ficos de Diamonds con Geoms Opcionales"),
    sidebarLayout(
        sidebarPanel(
            # Checkbox para mostrar u ocultar el histograma
            checkboxInput("show_hist", "Mostrar Histograma", value = TRUE),
            # Solo en caso de estar activado
            conditionalPanel(
                condition = "input.show_hist == true",
                numericInput("binwidth_hist", "Binwidth (histograma)", 
                             value = 0.5, min = 0.01, max = 5, step = 0.1)
            ),
            
            # Checkbox para el pol√≠gono de frecuencias
            checkboxInput("show_freq", "Mostrar Pol√≠gono de Frecuencias", value = TRUE),
            conditionalPanel(
                condition = "input.show_freq == true",
                numericInput("binwidth_freq", "Binwidth (pol√≠gono de frecuencias)", 
                             value = 0.5, min = 0.01, max = 5, step = 0.1)
            ),
            
            # Checkbox para la curva de densidad
            checkboxInput("show_density", "Mostrar Curva de Densidad", value = TRUE),
            conditionalPanel(
                condition = "input.show_density == true",
                numericInput("bw_density", "Bandwidth (densidad)", 
                             value = 1, min = 0.1, max = 5, step = 0.1)
            )
        ),
        mainPanel(
            plotOutput("resultado")
        )
    )
)

server <- function(input, output, session) {
    output$resultado <- renderPlot({
        p <- ggplot(diamonds, aes(carat))
        
        # Se agrega la capa del histograma si est√° activado
        if (input$show_hist) {
            p <- p + geom_histogram(binwidth = input$binwidth_hist, 
                                    fill = "skyblue", color = "black", alpha = 0.6)
        }
        
        # Se agrega la capa del pol√≠gono de frecuencias si est√° activado
        if (input$show_freq) {
            p <- p + geom_freqpoly(binwidth = input$binwidth_freq, 
                                   color = "darkgreen", linewidth = 1)
        }
        
        # Se agrega la capa de densidad si est√° activada
        if (input$show_density) {
            p <- p + geom_density(bw = input$bw_density, 
                                  color = "red", linewidth = 1)
        }
        
        p
    })
}

shinyApp(ui, server)
```

```{r, eval=FALSE}
# 10.2.3 Exercises (3) v3 IA

# esta otra soluci√≥n de IA superpone todas las gr√°ficas usando como factor de 
# conversi√≥n la relaci√≥n entre el conteo m√°ximo de un histograma, calculado con 
# graphics::hist() y la densidad m√°xima calculada con stats::density()

library(shiny)
library(ggplot2)

ui <- fluidPage(
    titlePanel("Gr√°ficos de Diamonds con Geoms Opcionales y Eje Secundario"),
    sidebarLayout(
        sidebarPanel(
            # Controles para el histograma
            checkboxInput("show_hist", "Mostrar Histograma", value = TRUE),
            conditionalPanel(
                condition = "input.show_hist == true",
                numericInput("binwidth_hist", "Anchura de cubeta (histograma)", 
                             value = 0.5, min = 0.01, max = 5, step = 0.1)
            ),
            
            # Controles para el pol√≠gono de frecuencias
            checkboxInput("show_freq", "Mostrar Pol√≠gono de Frecuencias", value = TRUE),
            conditionalPanel(
                condition = "input.show_freq == true",
                numericInput("binwidth_freq", "Anchura de cubeta (pol√≠gono de frecuencias)", 
                             value = 0.5, min = 0.01, max = 5, step = 0.1)
            ),
            
            # Controles para la curva de densidad
            checkboxInput("show_density", "Mostrar Curva de Densidad", value = TRUE),
            conditionalPanel(
                condition = "input.show_density == true",
                numericInput("bw_density", "Bandwidth (densidad)", 
                             value = 1, min = 0.1, max = 5, step = 0.1)
            )
        ),
        mainPanel(
            plotOutput("resultado")
        )
    )
)

server <- function(input, output, session) {
    output$resultado <- renderPlot({
        # --- 1. Calcular el valor de referencia (la altura m√°xima del histograma o del freqpoly)
        # Usamos el ancho de cubeta seg√∫n cu√°l est√© activado:
        # Si se muestra el histograma, usamos input$binwidth_hist, de lo contrario, si se muestra el freqpoly, usamos input$binwidth_freq.
        ref_binwidth <- if (input$show_hist) {
            input$binwidth_hist
        } else if (input$show_freq) {
            input$binwidth_freq
        } else {
            NA
        }
        
        if (!is.na(ref_binwidth)) {
            # Crear los "breaks" (l√≠mites de los bins) usando el rango de los datos
            breaks <- seq(min(diamonds$carat), max(diamonds$carat), by = ref_binwidth)
            if (max(breaks) < max(diamonds$carat)) {
                breaks <- c(breaks, max(diamonds$carat))
            }
            # Calcular el histograma sin graficar
            h <- hist(diamonds$carat, breaks = breaks, plot = FALSE)
            ref_max <- max(h$density)
        } else {
            ref_max <- NA
        }
        
        # --- 2. Calcular la m√°xima densidad de la curva (usando la funci√≥n base density())
        d <- density(diamonds$carat, bw = input$bw_density)
        dens_max <- max(d$y)
        
        # --- 3. Definir el factor de escalado; si no hay referencia, dejamos el factor en 1.
        scale_factor <- if (!is.na(ref_max) && dens_max > 0) {
            ref_max / dens_max
        } else {
            1
        }
        
        # --- Construir el gr√°fico
        p <- ggplot(diamonds, aes(carat))
        
        if (input$show_hist) {
            p <- p + geom_histogram(
                aes(y = after_stat(density)),
                binwidth = input$binwidth_hist,
                fill = "skyblue", color = "black", alpha = 0.6
            )
        }
        
        if (input$show_freq) {
            p <- p + geom_freqpoly(
                aes(y = after_stat(density)),
                binwidth = input$binwidth_freq,
                color = "darkgreen", linewidth = 1
            )
        }
        
        if (input$show_density) {
            p <- p + geom_density(
                aes(y = after_stat(density) * scale_factor),
                bw = input$bw_density,
                color = "red", linewidth = 1
            )
        }
        
        # Si tenemos referencia (por ejemplo, el histograma o freqpoly se muestran),
        # a√±adimos un eje secundario que "deshaga" el escalado para la densidad.
        if (!is.na(ref_max)) {
            p <- p + scale_y_continuous(
                name = "Densidad (histograma / pol√≠gono)",
                sec.axis = sec_axis(~ . / scale_factor, name = "Densidad (curva)")
            )
        }
        
        p + theme_minimal()
    })
}

shinyApp(ui, server)
```


```{r, eval=FALSE}
# 10.2.3 Exercises (3) v3 IA (modificado para tabsetPanel)

library(shiny)
library(ggplot2)

ui <- fluidPage(
    titlePanel("Gr√°ficos de Diamonds con Geoms Opcionales y Eje Secundario"),
    sidebarLayout(
        sidebarPanel(
            # Controles para el histograma
            checkboxInput("show_hist", "Mostrar Histograma", value = TRUE),
            # tabsetPanel oculto para el histograma
            tabsetPanel(
                id = "hist_controls", # ID √∫nico
                type = "hidden",
                tabPanel(
                    title = "hist_active",
                    numericInput("binwidth_hist", "Anchura de cubeta (histograma)", 
                                 value = 0.5, min = 0.01, max = 5, step = 0.1)
                ),
                tabPanel(title = "hist_inactive")
            ),
            
            # Controles para el pol√≠gono de frecuencias
            checkboxInput("show_freq", "Mostrar Pol√≠gono de Frecuencias", value = TRUE),
            # tabsetPanel oculto para el pol√≠gono de frecuencias
            tabsetPanel(
                id = "freq_controls", # ID √∫nico
                type = "hidden",
                tabPanel(
                    title = "freq_active",
                    numericInput("binwidth_freq", "Anchura de cubeta (pol√≠gono de frecuencias)", 
                                 value = 0.5, min = 0.01, max = 5, step = 0.1)
                ),
                tabPanel(title = "freq_inactive")
            ),
            
            # Controles para la curva de densidad
            checkboxInput("show_density", "Mostrar Curva de Densidad", value = TRUE),
            # tabsetPanel oculto para la densidad
            tabsetPanel(
                id = "density_controls", # ID √∫nico
                type = "hidden",
                tabPanel(
                    title = "density_active",
                    numericInput("bw_density", "Bandwidth (densidad)", 
                                 value = 1, min = 0.1, max = 5, step = 0.1)
                ),
                tabPanel(title = "density_inactive")
            )
        ),
        mainPanel(
            plotOutput("resultado")
        )
    )
)

server <- function(input, output, session) {
    # Observador para el histograma
    observeEvent(input$show_hist, {
        updateTabsetPanel(session, "hist_controls", 
                          selected = if(input$show_hist) "hist_active" else "hist_inactive")
    })
    
    # Observador para el pol√≠gono de frecuencias
    observeEvent(input$show_freq, {
        updateTabsetPanel(session, "freq_controls", 
                          selected = if(input$show_freq) "freq_active" else "freq_inactive")
    })
    
    # Observador para la curva de densidad
    observeEvent(input$show_density, {
        updateTabsetPanel(session, "density_controls", 
                          selected = if(input$show_density) "density_active" else "density_inactive")
    })

    output$resultado <- renderPlot({
        # --- 1. Calcular el valor de referencia (la altura m√°xima del histograma o del freqpoly)
        # Usamos el ancho de cubeta seg√∫n cu√°l est√© activado:
        # Si se muestra el histograma, usamos input$binwidth_hist, de lo contrario, si se muestra el freqpoly, usamos input$binwidth_freq.
        ref_binwidth <- if (input$show_hist) {
            input$binwidth_hist
        } else if (input$show_freq) {
            input$binwidth_freq
        } else {
            NA
        }
        
        if (!is.na(ref_binwidth)) {
            # Crear los "breaks" (l√≠mites de los bins) usando el rango de los datos
            breaks <- seq(min(diamonds$carat), max(diamonds$carat), by = ref_binwidth)
            if (max(breaks) < max(diamonds$carat)) {
                breaks <- c(breaks, max(diamonds$carat))
            }
            # Calcular el histograma sin graficar
            h <- hist(diamonds$carat, breaks = breaks, plot = FALSE)
            ref_max <- max(h$density)
        } else {
            ref_max <- NA
        }
        
        # --- 2. Calcular la m√°xima densidad de la curva (usando la funci√≥n base density())
        d <- density(diamonds$carat, bw = input$bw_density)
        dens_max <- max(d$y)
        
        # --- 3. Definir el factor de escalado; si no hay referencia, dejamos el factor en 1.
        scale_factor <- if (!is.na(ref_max) && dens_max > 0) {
            ref_max / dens_max
        } else {
            1
        }
        
        # --- Construir el gr√°fico
        p <- ggplot(diamonds, aes(carat))
        
        if (input$show_hist) {
            p <- p + geom_histogram(
                aes(y = after_stat(density)),
                binwidth = input$binwidth_hist,
                fill = "skyblue", color = "black", alpha = 0.6
            )
        }
        
        if (input$show_freq) {
            p <- p + geom_freqpoly(
                aes(y = after_stat(density)),
                binwidth = input$binwidth_freq,
                color = "darkgreen", linewidth = 1
            )
        }
        
        if (input$show_density) {
            p <- p + geom_density(
                aes(y = after_stat(density) * scale_factor),
                bw = input$bw_density,
                color = "red", linewidth = 1
            )
        }
        
        # Si tenemos referencia (por ejemplo, el histograma o freqpoly se muestran),
        # a√±adimos un eje secundario que "deshaga" el escalado para la densidad.
        if (!is.na(ref_max)) {
            p <- p + scale_y_continuous(
                name = "Densidad (histograma / pol√≠gono)",
                sec.axis = sec_axis(~ . / scale_factor, name = "Densidad (curva)")
            )
        }
        
        p + theme_minimal()
    })
}

shinyApp(ui, server)
```


------------------------------------------------------------------------

## √öltima caso y una herramienta muy poderosa... ‚ò¢

A veces hay que construir soluciones particulares en el momento

![](img/herramientas_gen√©ricas.jpg){width="50%"}

::: notes
Quiz√°s tenemos que llegar a muchas ventanas... no sabemos cu√°ntas ni qu√© tan alto est√° cada una...
:::

## Soluci√≥n üß†

Podemos crear din√°micamente (en tiempo de ejecuci√≥n) tantas soluciones como necesitemos y que se adapten a cada situaci√≥n

![](img/herramientas_adaptadas_al_destino.jpg){width="50%"}

::: notes
Ponemos a trabajar a shiny para crear tantos inputs como sea necesario
:::

------------------------------------------------------------------------

## 3. üöÄ Crear UI con C√≥digo (`renderUI`/`uiOutput`) üé®‚ú®

**üéØ Objetivo:**

Generar UI din√°micamente desde el servidor cuando las otras t√©cnicas no son suficientes (ej: n√∫mero arbitrario de inputs, tipos de input variables).

::: notes
Llegamos a la tercera y m√°s potente t√©cnica: **Crear UI con C√≥digo**, usando `renderUI()` y `uiOutput()`.

Esta t√©cnica es su salvavidas cuando las otras dos no son suficientes. Por ejemplo, si necesitan generar un n√∫mero *arbitrario* de inputs (no una cantidad fija de 2 o 3), o si el *tipo* de input que necesitan generar var√≠a din√°micamente, o si quieren construir un bloque de UI completamente nuevo y complejo.

¬øC√≥mo funciona? Es un patr√≥n de dos partes: [‚ñ∂]{style="color: #FF0000;"}
:::

. . .

**üîß C√≥mo:**

1.  **`uiOutput("outputId")` en la UI:** üìç Define un *lugar* donde se insertar√° la UI generada.

::: notes
1.  Primero, en la funci√≥n `ui`, se coloca un `uiOutput()`. Piensen en `uiOutput()` como un "marcador de posici√≥n" o un "espacio vac√≠o" en la UI donde se insertar√° el contenido generado din√°micamente. Le dan un `outputId` (como "dynamic_input_spot") para identificarlo. [‚ñ∂]{style="color: #FF0000;"}
:::

. . .

2.  **`output$outputId <- renderUI({...})` en el Server:** üèóÔ∏è C√≥digo R que genera el HTML (usando funciones `*Input`, `tags`, etc.) que se insertar√° en `uiOutput`.

::: notes
2.  Segundo, en la funci√≥n `server`, se define un `output` reactivo con el mismo `outputId` (ej: `output$dynamic_input_spot`). Y este `output` debe estar envuelto en `renderUI({...})`. Dentro de `renderUI`, escriben c√≥digo R normal que devuelve elementos de UI de Shiny (como `sliderInput()`, `numericInput()`, `div()`, `tags$p()`, etc.). El resultado de este c√≥digo R es HTML que Shiny inyecta en el `uiOutput` correspondiente en el navegador.

**¬øCu√°ndo necesitamos este patr√≥n?**

-   Cuando el n√∫mero de inputs es impredecible (¬ø3 variables? ¬ø30? ¬ø300?)
-   Cuando el tipo de control cambia radicalmente
-   Cuando quieren crear experiencias verdaderamente personalizadas

La desventaja principal de `renderUI` es que, como la UI se genera reactivamente, puede haber un peque√±o retraso o un "parpadeo" cuando se vuelve a renderizar, a diferencia de `update*Input` o `tabsetPanel` oculto que son m√°s fluidos.
:::

------------------------------------------------------------------------

### üé™ Ejemplo B√°sico: Crear Input Din√°mico

**üéØ Misi√≥n:** Crear un control que se transforme entre `sliderInput` y `numericInput` seg√∫n la elecci√≥n del usuario (para precisi√≥n puntual o facilitar un an√°lisis din√°mico)

```{r renderui-basic-app, eval=FALSE}
#| code-line-numbers: "1-19|1-5|2|2-3|2-4|6-18"
#| echo: true
#| RStudio-View: Showcase

ui <- fluidPage(
  textInput("label", "üìù Etiqueta", "Selecciona Label"),
  selectInput("type", "üéõÔ∏è Tipo", c("slider", "numeric")),
  uiOutput("dynamic_input_spot") # <-- üéØ Lugar para el input din√°mico
)
server <- function(input, output, session) {
  output$dynamic_input_spot <- renderUI({ # <-- üé® Genera la UI
    if (input$type == "slider") {
      sliderInput("dynamicValue", input$label, value = 0, min = 0, max = 10)
    } else {
      numericInput("dynamicValue", input$label, value = 0, min = 0, max = 10)
    }# üîë Clave: Ambos inputs tienen el mismo ID = "dynamicValue"
    # El input generado tendr√° id = "dynamicValue"
  })
  
  # Para ver el valor (opcional)
  # output$selectedValue <- renderText({ paste("Value:", input$dynamicValue) })
}
shinyApp(ui, server)
```

::: notes
Veamos un ejemplo b√°sico de `renderUI`. Nuestro objetivo es permitir al usuario elegir si quiere un `sliderInput` o un `numericInput`, y tambi√©n personalizar su etiqueta.

[‚ñ∂]{style="color: #FF0000;"} En la UI, tenemos: [‚ñ∂]{style="color: #FF0000;"}- Un `textInput` para que el usuario escriba la etiqueta (`input$label`). [‚ñ∂]{style="color: #FF0000;"}- Un `selectInput` para que elija el tipo de control (`input$type`), con opciones "slider" o "numeric". [‚ñ∂]{style="color: #FF0000;"}- Y lo m√°s importante, un `uiOutput("dynamic_input_spot")` (l√≠nea 4), que es donde aparecer√° nuestro control din√°mico.

[‚ñ∂]{style="color: #FF0000;"} En el servidor, definimos `output$dynamic_input_spot` dentro de un `renderUI` (l√≠nea 7). Este `renderUI` reacciona a los cambios en `input$type` o `input$label` (porque son los dos inputs o reactivos dentro del entorno reactivo de renderUI). Dentro de `renderUI`, tenemos una simple condici√≥n `if (input$type == "slider")`.

Si el tipo es "slider", devolvemos un `sliderInput`. De lo contrario, devolvemos un `numericInput`. Ambos inputs generados reciben el mismo `inputId`: "dynamicValue". Esto es imprescindible, ya que as√≠ podemos acceder al valor de este input generado a trav√©s de `input$dynamicValue`, sin importar si es un slider o un numeric input.

Si ejecutan esta aplicaci√≥n, ver√°n que al cambiar el selector de tipo o la etiqueta, el input debajo cambia din√°micamente.
:::

------------------------------------------------------------------------

### üß™ Caso de App creada por Jesi Formoso

```{r}
#| eval: false
#| include: true
library(webchem)
library(shiny)
library(shinythemes)

ui <- fluidPage(
    theme = shinytheme("cerulean"),
    
    titlePanel("Solutions Calculator"),
    
    sidebarLayout(
        sidebarPanel(
            selectInput("mode", "Select calculation:",
                        choices = c("Mass" = "mass",
                                    "Volume" = "volume",
                                    "Molarity" = "molarity")),
            textInput("compound", "Insert compound", value = ""),
            actionButton("search", "Search", class = "btn-primary"),
            verbatimTextOutput("molecular_weight", placeholder = TRUE)
        ),
        
        mainPanel(
            uiOutput("dynamic_inputs"),
            verbatimTextOutput("result", placeholder = TRUE)
        )
    )
)

server <- function(input, output, session) {
    
    options(scipen = 999)
    
    # Obtener peso molecular desde PubChem
    mol_weight <- eventReactive(input$search, {
        tryCatch({
            cid_result <- get_cid(input$compound, from = "name")
            if (nrow(cid_result) == 0 || is.na(cid_result$cid[1])) return(NA)
            cid <- cid_result$cid[1]
            prop <- pc_prop(cid, properties = "MolecularWeight")
            if (nrow(prop) == 0 || is.na(prop$MolecularWeight[1])) return(NA)
            as.numeric(prop$MolecularWeight[1])
        }, error = function(e) {
            print(e)
            return(NA)
        })
    })
    
    # Mostrar el peso molecular
    output$molecular_weight <- renderText({
        mw <- mol_weight()
        if (is.na(mw)) "Error: Compound not found or no molecular weight available."
        else paste("Molecular weight:", mw, "g/mol")
    })
    
    # Mostrar inputs seg√∫n el modo
    output$dynamic_inputs <- renderUI({
        switch(input$mode,
               
               "mass" = tagList(
                   fluidRow(
                       column(6, numericInput("concentration", "Concentration", value = 1, min = 0)),
                       column(6, selectInput("concentration_unit", "Unit", 
                                             choices = c("nM (nanomolar)" = "nM", "¬µM (micromolar)" = "uM", "mM (millimolar)" = "mM", "M (molar)" = "M")))
                   ),
                   fluidRow(
                       column(6, numericInput("volume", "Volume", value = 1, min = 0)),
                       column(6, selectInput("volume_unit", "Unit", 
                                             choices = c("¬µL (microliter)" = "uL", "mL (milliliter)" = "mL", "L (liter)" = "L")))
                   )
               ),
               
               "volume" = tagList(
                   numericInput("mass", "Mass (g)", value = 1, min = 0),
                   fluidRow(
                       column(6, numericInput("concentration", "Concentration", value = 1, min = 0)),
                       column(6, selectInput("concentration_unit", "Unit", 
                                             choices = c("nM (nanomolar)" = "nM", "¬µM (micromolar)" = "uM", "mM (millimolar)" = "mM", "M (molar)" = "M")))
                   )
               ),
               
               "molarity" = tagList(
                   numericInput("mass", "Mass (g)", value = 1, min = 0),
                   fluidRow(
                       column(6, numericInput("volume", "Volume", value = 1, min = 0)),
                       column(6, selectInput("volume_unit", "Unit", 
                                             choices = c("¬µL (microliter)" = "uL", "mL (milliliter)" = "mL", "L (liter)" = "L")))
                   )
               )
        )
    })
    
    # Calcular resultado
    output$result <- renderText({
        mw <- mol_weight()
        if (is.null(mw) || is.na(mw)) return("Please search for a valid compound first.")
        
        mode <- input$mode
        
        # Unidades
        conc_factor <- switch(input$concentration_unit,
                              "nM" = 1e-9, "uM" = 1e-6, "mM" = 1e-3, "M" = 1)
        
        vol_factor <- switch(input$volume_unit,
                             "uL" = 1e-6, "mL" = 1e-3, "L" = 1)
        
        if (mode == "mass") {
            c <- input$concentration * conc_factor
            v <- input$volume * vol_factor
            mass <- c * v * mw
            return(paste("Mass =", signif(mass, 5), "g"))
            
        } else if (mode == "volume") {
            c <- input$concentration * conc_factor
            if (c == 0) return("Concentration must be greater than zero.")
            vol_L <- input$mass / (c * mw)
            return(paste("Volume =", signif(vol_L * 1e3, 5), "mL"))  # muestra en mL
            
        } else if (mode == "molarity") {
            v <- input$volume * vol_factor
            if (v == 0) return("Volume must be greater than zero.")
            molarity <- input$mass / (v * mw)
            return(paste("Molarity =", signif(molarity, 5), "mol/L"))
        }
    })
}

shinyApp(ui, server)

```

::: notes
**Ejemplo de UI Din√°mica con renderUI y uiOutput**

Esta aplicaci√≥n fue dise√±ada para ilustrar c√≥mo podemos crear interfaces de usuario que se adaptan en tiempo real a partir de par√°metros definidos por el usuario y de datos externos.

- **Selecci√≥n del modo de c√°lculo:**  
  El **selectInput** llamado `"mode"` permite elegir entre tres modos de c√°lculo ‚Äî *mass*, *volume* y *molarity* ‚Äî. Seg√∫n la opci√≥n escogida, se generan controles espec√≠ficos en el panel principal utilizando `renderUI()` en conjunto con `uiOutput("dynamic_inputs")`.

- **Generaci√≥n din√°mica de controles:**  
  En el servidor, la funci√≥n `renderUI()` usa un `switch` para evaluar el valor de `input$mode` y, mediante **tagList** y `fluidRow`, genera las filas y columnas correspondientes con controles como `numericInput` y `selectInput`. Este enfoque permite que la interfaz se adapte sin necesidad de tener todos los controles visibles o renderizados de manera permanente.

- **Integraci√≥n con webchem para obtener datos externos:**  
  Con una funci√≥n reactiva basada en `eventReactive(input$search, { ‚Ä¶ })` se busca el peso molecular del compuesto ingresado por el usuario. Al capturar el resultado de la consulta a PubChem (usando la funci√≥n `get_cid` y `pc_prop` de la librer√≠a **webchem**), se integra de manera interactiva la informaci√≥n qu√≠mica a los c√°lculos.

- **C√°lculo y presentaci√≥n de resultados:**  
  Dependiendo del modo seleccionado, se realizan diferentes operaciones de c√°lculo (usando factores de conversi√≥n seg√∫n la unidad) y se muestra el resultado de forma reactiva mediante `renderText()` en el output `"result"`.

- **Aspectos extras:**  
  La aplicaci√≥n utiliza el tema **cerulean** de `shinythemes` para mejorar la est√©tica y demuestra buenas pr√°cticas en el manejo de errores (con `tryCatch`) y en la validaci√≥n de entradas con `req()`.  
   
Este ejemplo es un excelente caso para entender c√≥mo la generaci√≥n din√°mica de UI puede simplificar la estructura de una aplicaci√≥n y hacerla m√°s flexible, adapt√°ndose a distintos escenarios de entrada y proceso. Es una buena base de partida para explorar aplicaciones interactivas m√°s complejas en Shiny.
:::

------------------------------------------------------------------------

### üß† Preservar Estado al Recrear UI üîÑ

**‚ö†Ô∏è Problema:** Cuando `renderUI` se re-ejecuta (ej: al cambiar `input$type`), la UI anterior se destruye y se crea una nueva. üò± ¬°Se pierde el valor que el usuario hab√≠a introducido! üò±

**‚ú® Soluci√≥n:** Usar `isolate()` para leer el valor *actual* del input (si existe) y usarlo como `value` inicial del *nuevo* input.

```{r renderui-preserve-state-app, eval=FALSE}
#| code-line-numbers: "|11|13-17"
#| echo: true
#| RStudio-View: Showcase

# ui es la misma que antes
ui <- fluidPage(
  textInput("label", "label", "Select Label"),
  selectInput("type", "type", c("slider", "numeric")),
  uiOutput("dynamic_input_spot") 
)

server <- function(input, output, session) {
  output$dynamic_input_spot <- renderUI({ 
    # üß† Memoria: Lee el valor actual SIN crear dependencia reactiva en input$dynamicValue
    current_value <- isolate(input$dynamicValue) %||% 0 # Usa 0 si no existe a√∫n
    
    if (input$type == "slider") {
      sliderInput("dynamicValue", input$label, value = current_value, min = 0, max = 10) # üéØ Preserva el valor
    } else {
      numericInput("dynamicValue", input$label, value = current_value, min = 0, max = 10) # üéØ Preserva el valor
    }
  })
}
shinyApp(ui, server)
```

**üîë Clave:** `isolate()` = "Lee este valor, pero NO hagas que me reactive por √©l"

::: notes
Hay una piedra en el camino al usar `renderUI`: la p√©rdida de estado.

Cuando `renderUI` se re-ejecuta (por ejemplo, porque cambiamos `input$type` de "slider" a "numeric"), Shiny *destruye* el elemento UI anterior y *crea uno completamente nuevo*. Si el usuario hab√≠a introducido un valor en el input anterior (ej: 5 en el slider), ese valor se pierde y el nuevo input (el numericInput) aparece con su valor por defecto (0). Esto es una mala experiencia de usuario.

La soluci√≥n es **preservar el estado** usando `isolate()`. F√≠jense en la l√≠nea 11. [‚ñ∂]{style="color: #FF0000;"} Antes de generar el nuevo input, intentamos leer el `current_value` de `input$dynamicValue` usando `isolate(input$dynamicValue)`. - `isolate()` es crucial aqu√≠. Le dice a Shiny: "Lee el valor de `input$dynamicValue`, pero **no** hagas que este `renderUI` se dispare de nuevo si *solo* `input$dynamicValue` cambia." Queremos que `renderUI` se reactive cuando `input$type` o `input$label` cambien, no cuando el usuario interact√∫e con el propio input din√°mico. - `%||%` es un helper de Shiny, operador de coalescencia (fusi√≥n) nula, que tambi√©n est√° en purrr y R base reciente 4.4.0+, que significa "si lo que est√° a la izquierda es `NULL` us√° lo que pongo a la derecha (lo cual ocurre la primera vez que se carga la app o si el input se destruye y no existe a√∫n), en esos casos, `isolate(input$dynamicValue)%||% 0`entonces, usa 0 como valor por defecto".

[‚ñ∂]{style="color: #FF0000;"}Luego, pasamos este `current_value` como el `value` inicial del `sliderInput` o `numericInput` que estamos creando.

As√≠, cuando el tipo de input cambia, el nuevo input se genera con el √∫ltimo valor que el usuario hab√≠a introducido, manteniendo la experiencia fluida.
:::

------------------------------------------------------------------------

## üé≠ M√∫ltiples Controles Din√°micos (1) {.smaller}

**üéØ Objetivo:** Generar un n√∫mero arbitrario de controles (ej: `textInput` para N colores).

**üé® Ejemplo:** Inputs para colores de una paleta

**üîß T√©cnica:** Usando programaci√≥n funcional (`purrr::map` o `lapply`) dentro de `renderUI`.

![](img/app_ui_output.jpg){fig-align="center" width="40%"}

------------------------------------------------------------------------

## üé≠ M√∫ltiples Controles Din√°micos (2) {.smaller}

**üèóÔ∏è Arquitectura:**

-   **UI (parte clave):** Un `numericInput("n")` para definir la cantidad, y un `uiOutput("col_inputs")` para el lugar donde aparecer√°n los `textInput` din√°micos.

**üîë Secretos del √âxito:**

\- üè∑Ô∏è Generar nombres de ID √∫nicos (`col_names`).

\- üîÑ Usar `map()` o `lapply()` para crear la lista de componentes UI.

\- üéØ Acceder a valores de input din√°micos con `input[[inputId_string]]`.

\- üß† Usar`isolate()` y `%||%` para preservar estado y manejar`NULL\`s.

------------------------------------------------------------------------

## C√≥digo funcional para obtener una lista de elementos de UI

```{r renderui-multiple-app-ui, eval=FALSE, echo=TRUE}
#| code-line-numbers: "|1-6|3-4|9-10|9-10,12-18|20-24"
# UI completa (extracto relevante)
ui <- fluidPage(
  numericInput("n", "Number of colours", value = 3, min = 1),
  uiOutput("col_inputs"), # Lugar para los textInput
  textOutput("palette")  # Para mostrar los colores ingresados
)

server <- function(input, output, session) {
  # Define IDs de los inputs din√°micos
  col_names <- reactive(paste0("col", seq_len(input$n))) # col1, col2, col3, ...
  
  # Genera la UI con N textInput
  output$col_inputs <- renderUI({ 
    map(col_names(), ~ {
      current_val <- isolate(input[[.x]]) # Preserva valor
      textInput(.x, label = NULL, value = current_val %||% "")
    })
  })
  
  # Recolecta y muestra los valores
  output$palette <- renderText({ 
    values <- map_chr(col_names(), ~ input[[.x]] %||% "")
    paste(values, collapse = ", ")
  })
}

shinyApp(ui, server)
```


::: notes
`renderUI` brilla cuando necesitas generar un n√∫mero *arbitrario* de controles. Imagina que quieres que el usuario introduzca una lista de colores, y el n√∫mero de colores puede variar.

Vamos a ejecutar el c√≥digo para ver de qu√© se trata (ir a ejemplo_completo_swatch en Parte UI (extracto)) y enseguida volvemos.

[‚ñ∂]{style="color: #FF0000;"}
[‚ñ∂]{style="color: #FF0000;"}

Vemos el **objetivo** (de generar N inputs), c√≥mo se logra? usando **programaci√≥n funcional** con `map` o `lapply`, y la **estructura clave de la UI**: un `numericInput` para `n` y un `uiOutput` para los inputs din√°micos. 

[‚ñ∂]{style="color: #FF0000;"}
Finalmente, las **claves** de la implementaci√≥n, como generar IDs √∫nicos con el reactivo col_names(), 


[‚ñ∂]{style="color: #FF0000;"}
usar `map` en la definici√≥n de `output$col_inputs` dentro de un `renderUI`, donde `map` se usa para crear los `textInput` individuales. F√≠jense c√≥mo se usa `isolate(input[[.x]]) %||% ""` para preservar el valor de cada input din√°mico.


Noten la importancia de `isolate()` en la l√≠nea 15 para preservar el estado.


[‚ñ∂]{style="color: #FF0000;"}
\- Y finalmente agrego una concatenaci√≥n de los nombres de los colores con `output$palette`, que recolecta los valores de todos los inputs generados din√°micamente usando `map_chr(col_names(), ~ input[[.x]] %||% "")` y los une en una cadena.

Este patr√≥n con `map` es incre√≠blemente poderoso para construir UI que se adapta a las necesidades del usuario, sin tener que codificar manualmente cada posible combinaci√≥n.

Se puede ir al c√≥digo para ejecutarlo.
:::


```{r ejemplo_completo_swatch}
#| eval: false
#| include: false
library(shiny)
library(ggplot2)

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      numericInput("n", "Number of colours", value = 3, min = 1),
      uiOutput("col"),
    ),
    mainPanel(
      plotOutput("plot")
    )
  )
)

server <- function(input, output, session) {
  col_names <- reactive(paste0("col", seq_len(input$n))) # genera los nombres de textInput para los colores

  output$col <- renderUI({
    map(col_names(), ~ textInput(.x, NULL, value = isolate(input[[.x]]))) # crea UI (textInput) con inputID desde col_names, con el label vac√≠o, con el valor por defecto que surge de recordar lo √∫ltimo que el usuario le dio
  })

  output$plot <- renderPlot({ # realiza el plot
    cols <- map_chr(col_names(), ~ input[[.x]] %||% "") #primero genera una lista de characters con el contenido de los input$col1, input$col2, etc.
    # convert empty inputs to transparent
    cols[cols == ""] <- NA # si hubiera alg√∫n elemento vac√≠o le asigna NA

    barplot(                 # devuelve un diagrama de barras
      rep(1, length(cols)),  # donde primero hay un vector de 1's repetidos tantas veces como colores hay
      col = cols,            # con los colores que se dieron a los input[[col1]], etc
      space = 0,
      axes = FALSE           # no se dibujan los ejes
    )
  }, res = 96)
}

shinyApp(ui, server)
```

------------------------------------------------------------------------

### üìù Caso de Uso: Filtrado Din√°mico de Data Frames

**Objetivo:** Crear controles de filtro autom√°ticamente basados en los tipos de columna de un data frame seleccionado.

-   Num√©rico -\> `sliderInput` (rango). 
-   Factor -\> `selectInput` (m√∫ltiple).

::: notes
Este es uno de los ejemplos m√°s completos y realistas para `renderUI`: la creaci√≥n de **filtros din√°micos para un data frame**.

Imagina una aplicaci√≥n donde el usuario selecciona un dataset, y t√∫ quieres generar autom√°ticamente los controles de filtro adecuados para cada columna de ese dataset. Por ejemplo, si una columna es num√©rica, quieres un `sliderInput` para filtrar por rango. Si es un factor, un `selectInput` para elegir m√∫ltiples niveles

:::

------------------------------------------------------------------------

### üìù Caso de Uso: Filtrado Din√°mico de Data Frames

**Estrategia:** 

1.  Helper `make_ui(col_data, col_name)`: Genera el control UI apropiado.
2.  Helper `filter_var(col_data, input_val)`: Devuelve vector l√≥gico de filtro para esa columna. 
3.  En UI: `selectInput("dataset")`, `uiOutput("filter_controls")`. 
4.  En Server: -   `reactive(data())`: Obtiene el dataset seleccionado.
    -   `reactive(vars())`: Obtiene nombres de columnas. 
    -   `renderUI`: Usa `map(vars(), ~ make_ui(data()[[.x]], .x))` para generar todos los controles.     -   `reactive(selected())`: Usa `map()` para obtener filtros l√≥gicos por variable y `reduce(`&`)` para combinarlos. 
    -   `renderTable`: Muestra `data()[selected(), ]`.

::: notes

La estrategia se divide en varios componentes:   

1. Una funci√≥n de ayuda `make_ui()` que toma los datos de una columna y su nombre, y devuelve el control UI apropiado (`sliderInput`, `selectInput`, o `NULL` si no es un tipo soportado). 

2. Otra funci√≥n de ayuda `filter_var()` que toma los datos de una columna y el valor del input del filtro, y devuelve un vector l√≥gico (`TRUE`/`FALSE`) que indica qu√© filas cumplen con el filtro. 

3. En la UI, solo necesitamos un `selectInput` para el dataset y un `uiOutput` donde se insertar√°n todos los controles de filtro. 

4. En el servidor, la l√≥gica es m√°s elaborada:
    - Un reactivo `data()` para cargar el dataset seleccionado. 
    - Un reactivo `vars()` para obtener los nombres de las columnas. 
    - El `renderUI` es la pieza central: usa `map()` para iterar sobre las columnas y llamar a `make_ui()` para cada una, generando todos los controles de filtro. 
    - Un reactivo `selected()` es donde ocurre la l√≥gica de filtrado: tambi√©n usa `map()` para aplicar `filter_var()` a cada columna con su input correspondiente, y luego `reduce()` de `purrr` para combinar todos esos vectores l√≥gicos con un `&` (AND) para obtener el filtro final. 
    - Finalmente, un `renderTable` muestra las primeras 12 filas del data frame filtrado.

Este es un patr√≥n de dise√±o muy potente para construir aplicaciones flexibles que se adaptan a la estructura de los datos del usuario.

:::

------------------------------------------------------------------------

### Filtrado Din√°mico: C√≥digo

```{r dynamic-filter-app, eval=FALSE}
#| echo: true
#| RStudio-View: Showcase
#| code-line-numbers: "false"

library(purrr)
library(dplyr)

# Helper para crear UI por tipo de variable (recibe un vector y un nombre)
make_ui <- function(x, var) {
  if (is.numeric(x)) {
    rng <- range(x, na.rm = TRUE)
    sliderInput(var, var, min = rng[1], max = rng[2], value = rng)
  } else if (is.factor(x)) {
    levs <- levels(x)
    selectInput(var, var, choices = levs, selected = levs, multiple = TRUE)
  } else {
    # Otros tipos no soportados -> no genera control
    NULL 
  }
}

# Helper para filtrar datos basado en el input (recibe un vector y el rango de
# valores que ingreso el usuario en el input generado). Devuelve un vector 
# l√≥gico, que luego podr√° operarse l√≥gicamente con los de las otras variables 
filter_var <- function(x, val) {
  if (is.numeric(x)) {
    !is.na(x) & x >= val[1] & x <= val[2]
  } else if (is.factor(x)) {
    x %in% val # Si es NULL (a√∫n no existe input), esto da TRUE para todos (ok)
  } else {
    TRUE # No filtrar si no hay control
  }
}

# Lista de data frames en 'datasets'
dfs <- keep(ls("package:datasets"), ~ is.data.frame(get(.x, "package:datasets")))

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      selectInput("dataset", label = "Dataset", choices = dfs),
      uiOutput("filter") # Lugar para los controles de filtro
    ),
    mainPanel(
      tableOutput("data")
    )
  )
)

server <- function(input, output, session) {
  # Datos seleccionados
  data <- reactive({
    req(input$dataset) # nos aseguramos que input$dataset sea truthy (que no sea FALSE, NULL,"", etc)
    get(input$dataset, "package:datasets") # devuelve el objeto que tiene el nombre input$dataset
  })
  
  # Nombres de variables del dataset
  vars <- reactive(names(data())) # necesitaremos un vector de nombres (lo que es usual en programaci√≥n funcional)
  
  # Genera los controles de filtro en la UI
  output$filter <- renderUI({
      # data()[[.x]] es la forma de conseguir el vector desde el reactivo de los nombres: vars()
      # .x es la forma de conseguir el nombre desde vars()
    map(vars(), ~ make_ui(data()[[.x]], .x)) # con los vectores y los nombres genera los input
  })
  
  # L√≥gica de filtrado combinada (selected() es un reactivo que devuelve un vector l√≥gico)
  selected <- reactive({
    # Aplica filter_var a cada variable/input correspondiente
    each_var <- map(vars(), ~ filter_var(data()[[.x]], input[[.x]])) # 
    # Combina todos los vectores l√≥gicos con &, o sea con la operaci√≥n logical1 & logical2 & logical3
      # reduce(list(TRUE, TRUE, TRUE), `&`) # que es como (TRUE & TRUE) & TRUE
      # [1] TRUE
      # reduce(list(TRUE, TRUE, FALSE), `&`)
      # [1] FALSE
    reduce(each_var, `&`)
    # Alternativa base R: Reduce(`&`, each_var)
  })
  
  # Muestra la tabla filtrada
  output$data <- renderTable({
    req(selected()) # Espera a que el filtro est√© listo
    head(data()[selected(), , drop = FALSE], 12) # drop=FALSE por si queda 1 col, que no intente convertirlo en un vector (ver el par√°metro drop en la ayuda de ?`[`)
  })
}

shinyApp(ui, server)
```

::: notes
Aqu√≠ est√° el c√≥digo completo para el filtrado din√°mico. No lo ejecutaremos en vivo por la complejidad, pero les explicar√© los detalles.

Las funciones `make_ui` y `filter_var` son el coraz√≥n de la flexibilidad. 
- `make_ui` usa `if/else` para comprobar si la columna `x` es num√©rica o un factor, y devuelve un `sliderInput` o un `selectInput` respectivamente. Si no es ninguno de esos, devuelve `NULL`, lo que significa que no se generar√° un control de filtro para esa columna. 
- `filter_var` obtiene un vector l√≥gico que ser√° usado luego para filtrar. 

Para num√©ricos, comprueba si el valor est√° dentro del rango del slider. 
Para factores, comprueba si los niveles de la columna est√°n entre los seleccionados en el `selectInput` m√∫ltiple. 

Es importante notar que si un input din√°mico a√∫n no ha sido creado, `input[[.x]]` ser√° `NULL`, y `filter_var` est√° dise√±ado para manejarlo (ej: `x %in% NULL` en R devuelve un vector de `FALSE` para todas las filas, lo cual es correcto si no hay selecci√≥n).

En el servidor, `data()` y `vars()` son reactivos que recuperan el dataset y sus nombres de columna. `output$filter <- renderUI({...})` usa `map` para llamar a `make_ui` para cada columna, generando una lista de controles de UI que Shiny renderiza en el `uiOutput("filter")`.

Finalmente, `selected <- reactive({...})` es el reactivo que hace el filtrado. Tambi√©n usa `map` para llamar a `filter_var` para cada columna (pas√°ndole los datos de la columna y el valor de su input din√°mico). Esto devuelve una lista de vectores l√≥gicos. Luego, `purrr::reduce(each_var, \`&\`)`combina todos esos vectores l√≥gicos con la operaci√≥n AND (`&`), d√°ndonos un √∫nico vector l√≥gico que indica qu√© filas deben mostrarse. El`output\$data\` simplemente muestra las primeras 12 filas del dataset filtrado.

Esta aplicaci√≥n es un excelente ejemplo de c√≥mo combinar las habilidades de reactividad, `renderUI` y programaci√≥n funcional para crear una interfaz de usuario altamente adaptable.
:::

------------------------------------------------------------------------

### T√©cnica Relacionada: Cuadros de Di√°logo (`modalDialog`)

-   `showModal(modalDialog(...))` se llama desde el servidor.
-   El contenido del `modalDialog(...)` puede ser UI *generada din√°micamente*, igual que con `renderUI`.
-   √ötil para solicitar informaci√≥n espec√≠fica al usuario antes de continuar.

**Ejemplo (Ejercicio 10.3.5.2):** Pedir contrase√±a.

```{r modal-password-app, eval=FALSE}
#| echo: true
#| RStudio-View: Showcase
ui <- fluidPage(
  actionButton("go", "Enter password"),
  textOutput("text")
)
server <- function(input, output, session) {
  observeEvent(input$go, {
    showModal(modalDialog(
      # UI dentro del modal
      passwordInput(inputId = "password", label = NULL), #NULL para no dar una label 
      title = "Please enter your password",
      footer = modalButton("Cerrar ventana modal") # A√±adir bot√≥n para cerrar
    ))
  })
  
  output$text <- renderText({
    # isTruthy eval√∫a NULL, "", FALSE como FALSE
    if (!isTruthy(input$password)) {
      "No password"
    } else {
      "Password entered" # (No muestra la contrase√±a real)
    }
  })
}
shinyApp(ui, server)
```

> **¬øPor qu√© desaparece la contrase√±a?** Cada vez que se hace clic en "Enter password", `showModal` se llama de nuevo, creando una instancia *nueva* del `modalDialog` con un `passwordInput` *nuevo* (vac√≠o). El input anterior (`input$password`) sigue existiendo en el servidor pero ya no est√° visible ni asociado al nuevo di√°logo.

::: notes
Una t√©cnica relacionada con la generaci√≥n de UI din√°mica es el uso de **cuadros de di√°logo modales** con `modalDialog()`.

Un `modalDialog` es una ventana emergente que se superpone a la aplicaci√≥n principal y requiere la interacci√≥n del usuario antes de poder continuar. Se muestra llamando a `showModal()` desde el servidor.

Lo importante aqu√≠ es que el contenido de un `modalDialog` se define de la misma manera que se define la UI en general, e incluso puede contener UI *generada din√°micamente* como si fuera un `renderUI`. Esto es √∫til para pedir confirmaciones, recoger informaci√≥n adicional o mostrar mensajes importantes.

El ejemplo aqu√≠ muestra un bot√≥n "Enter password" y un `textOutput`. Cuando se hace clic en el bot√≥n, el `observeEvent` llama a `showModal()`. Dentro del `modalDialog`, creamos un `passwordInput` con el ID "password".

El `output$text` comprueba y nos informa si se ha introducido una contrase√±a.

Ahora, un punto importante a considerar con los modales: si el usuario introduce una contrase√±a, cierra el modal, y luego vuelve a hacer clic en "Enter password", ver√° que el campo de contrase√±a est√° vac√≠o de nuevo. Esto es porque `showModal()` cada vez que se llama, *crea una nueva instancia* del `modalDialog` y de todos sus inputs. Aunque el valor `input$password` en el servidor a√∫n conserva lo que se escribi√≥ la primera vez, el nuevo `passwordInput` en el modal es una entidad separada y vac√≠a. Esto es algo a tener en cuenta para la experiencia de usuario.
:::

------------------------------------------------------------------------

### üë©‚Äçüíª/üë®‚Äçüíª Ejercicios (Secci√≥n 10.3.5)

1.  **Alternativa a `renderUI`:** Reimplementar el primer ejemplo (slider/numeric) usando `conditionalPanel` o `tabsetPanel` oculto. ¬øC√≥mo mantener valores sincronizados?

```{r, eval=FALSE}
ui <- fluidPage(
  selectInput("type", "type", c("slider", "numeric")),
  uiOutput("numeric")
)
server <- function(input, output, session) {
  output$numeric <- renderUI({
    if (input$type == "slider") {
      sliderInput("n", "n", value = 0, min = 0, max = 100)
    } else {
      numericInput("n", "n", value = 0, min = 0, max = 100)
    }
  })
}
shinyApp(ui, server)
```

Soluci√≥n con tabPanel():

Me cost√≥ ver que ten√≠a que darle diferente inputID y hacer dos isolate()¬¥s

```{r, eval=FALSE}
ui <- fluidPage(
    selectInput("type", "type", c("slider", "numeric")),
    tabsetPanel(
        id = "switcher",  
        type = "hidden",  
        tabPanel("slider",
                 sliderInput("n_slider", "n", value = 0, min = 0, max = 100)),
        tabPanel("numeric",
                 numericInput("n_numeric", "n", value = 0, min = 0, max = 100) 
        )
      )
  # uiOutput("numeric")
)
server <- function(input, output, session) {
    observeEvent(input$type, {
        current_val_slider <- isolate(input[["n_slider"]]) # Preserva valor
        current_val_numeric <- isolate(input[["n_numeric"]]) # Preserva valor
        updateTabsetPanel(session, inputId = "switcher", selected = input$type)
        if(input$type == "slider"){
            updateSliderInput(session,inputId = "n_slider", "n", value = current_val_numeric %||% 0)
        }else{
            updateNumericInput(session,inputId = "n_numeric", "n", value = current_val_slider %||% 0)
        }
  })
  
}
shinyApp(ui, server)


```

o con TabPanelBody() tambi√©n funcionar√≠a (aqu√≠ no implemento isolate()):
```{r, eval=FALSE}
ui <- fluidPage(
    selectInput("type", "type", c("slider", "numeric")),
    tabsetPanel(
        id = "switcher",  
        type = "hidden",  
        tabPanelBody("slider",
                 sliderInput("n", "n", value = 0, min = 0, max = 100)),
        tabPanelBody("numeric",
                 numericInput("n", "n", value = 0, min = 0, max = 100) 
        )
      )
  # uiOutput("numeric")
)
server <- function(input, output, session) {
    observeEvent(input$type, {
        updateTabsetPanel(session, inputId = "switcher", selected = input$type)
  })
  
}
shinyApp(ui, server)


```

------------------------------------------------------------------------

2.  **Contrase√±a Modal:** Explicado en la diapositiva anterior.

------------------------------------------------------------------------

3.  **`isolate()`:** ¬øQu√© pasa si se quita `isolate()` en el ejemplo de `renderUI` que preserva estado? (Respuesta: value quedar√≠a en NA, deber√≠a usar %||% 0 para no darle un NA al value de slider, por eso da error "Error: In sliderInput(): `min`, `max`, and `value` cannot be NULL, NA, or empty."). Habr√≠a esperado que entrara en un loop infinito. Podemos ver en el c√≥digo de abajo diferentes situaciones... siempre que use el null coalescing operator funcionar√°.

```{r ejemplo_completo_swatch_ejercicio}
#| eval: false
#| include: false

ui <- fluidPage(
  textInput("label", "label"),
  selectInput("type", "type", c("slider", "numeric")),
  uiOutput("numeric")
)

server <- function(input, output, session) {
  output$numeric <- renderUI({
    # value <- input$dynamic
    # value <- isolate(input$dynamic)
    value <- isolate(input$dynamic) %||% 0
    # value <- input$dynamic %||% 0
    
    # if(is.na(value))print("value es NA")
    # if(is.null(value))print("value es NULL")
    # print(value)
    if (input$type == "slider") {
      sliderInput("dynamic", input$label, value = value, min = 0, max = 10)
    } else {
      numericInput("dynamic", input$label, value = value, min = 0, max = 10)
    }
  })
}

shinyApp(ui, server)

```

------------------------------------------------------------------------

4.  **Soporte Fechas:** Extender `make_ui` y `filter_var` para manejar columnas `Date` y `POSIXct`.

```{r dynamic-filter-app_ejercicio, eval=FALSE}
#| echo: true
#| RStudio-View: Showcase
#| code-line-numbers: "false"

library(purrr)
library(dplyr)

# Helper para crear UI por tipo de variable (recibe un vector y un nombre)
make_ui <- function(x, var) {
  if (is.numeric(x)|inherits(x, "Date")| inherits(x, "POSIXct")) {
    rng <- range(x, na.rm = TRUE)
    sliderInput(var, var, min = rng[1], max = rng[2], value = rng)
  } else if (is.factor(x)) {
    levs <- levels(x)
    selectInput(var, var, choices = levs, selected = levs, multiple = TRUE)
  } else {
    # Otros tipos no soportados -> no genera control
    NULL 
  }
}

# Helper para filtrar datos basado en el input (recibe un vector y el rango de
# valores que ingreso el usuario en el input generado). Devuelve un vector 
# l√≥gico, que luego podr√° operarse l√≥gicamente con los de las otras variables 
filter_var <- function(x, val) {
    
    # sugerencia copilot:
      # Si a√∫n no existe el input, no filtro nada:
  if (is.null(val)) return(rep(TRUE, length(x)))

  if (is.numeric(x)|inherits(x, "Date")| inherits(x, "POSIXct")) {
    !is.na(x) & x >= val[1] & x <= val[2]
  } else if (is.factor(x)) {
    x %in% val # Si es NULL (a√∫n no existe input), esto da TRUE para todos (ok)
  } else {
    TRUE # No filtrar si no hay control
  }
}

# Lista de data frames en 'datasets'
dfs <- keep(ls("package:datasets"), ~ is.data.frame(get(.x, "package:datasets")))

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      selectInput("dataset", label = "Dataset", choices = dfs),
      uiOutput("filter") # Lugar para los controles de filtro
    ),
    mainPanel(
      tableOutput("data")
    )
  )
)

server <- function(input, output, session) {
  # Datos seleccionados
  data <- reactive({
    req(input$dataset) # nos aseguramos que input$dataset sea truthy (que no sea FALSE, NULL,"", etc)
    get(input$dataset, "package:datasets") # devuelve el objeto que tiene el nombre input$dataset
  })
  
  # Nombres de variables del dataset
  vars <- reactive(names(data())) # necesitaremos un vector de nombres (lo que es usual en programaci√≥n funcional)
  
  # Genera los controles de filtro en la UI
  output$filter <- renderUI({
      # data()[[.x]] es la forma de conseguir el vector desde el reactivo de los nombres: vars()
      # .x es la forma de conseguir el nombre desde vars()
    # sugerencia de Copilot:
      # - Envuelve la lista de controles que te devuelve map() en un tagList(). Si devuelves una lista cruda, Shiny tampoco sabe c√≥mo pegarla en la UI, y genera abortos en renderUI.

      # map(vars(), ~ make_ui(data()[[.x]], .x)) # con los vectores y los nombres genera los input
        ui_elems <- map(vars(), ~ make_ui(data()[[.x]], .x))
  do.call(tagList, ui_elems)

  })
  
  # L√≥gica de filtrado combinada (selected() es un reactivo que devuelve un vector l√≥gico)
  selected <- reactive({
    # Aplica filter_var a cada variable/input correspondiente
    each_var <- map(vars(), ~ filter_var(data()[[.x]], input[[.x]])) # 
    # Combina todos los vectores l√≥gicos con &, o sea con la operaci√≥n logical1 & logical2 & logical3
      # reduce(list(TRUE, TRUE, TRUE), `&`) # que es como (TRUE & TRUE) & TRUE
      # [1] TRUE
      # reduce(list(TRUE, TRUE, FALSE), `&`)
      # [1] FALSE
    reduce(each_var, `&`)
    # Alternativa base R: Reduce(`&`, each_var)
  })
  
  # Muestra la tabla filtrada
  output$data <- renderTable({
    req(selected()) # Espera a que el filtro est√© listo
    head(data()[selected(), , drop = FALSE], 12) # drop=FALSE por si queda 1 col, que no intente convertirlo en un vector (ver el par√°metro drop en la ayuda de ?`[`)
  })
}

shinyApp(ui, server)
```

------------------------------------------------------------------------

5.  **(Avanzado S3):** Reemplazar `if/else` en `make_ui`/`filter_var` con m√©todos S3.

Ventajas de usar S3:
Modularidad y escalabilidad: Al separar la l√≥gica en m√©todos S3 espec√≠ficos para cada tipo de dato, la soluci√≥n se vuelve mucho m√°s modular. Si se requiere dar soporte a nuevos tipos (por ejemplo, Date o POSIXct), bastar√≠a con agregar nuevas definiciones make_ui.<tipo> y filter_var.<tipo> sin alterar la estructura general.

Legibilidad y mantenimiento: La eliminaci√≥n de m√∫ltiples condicionales dentro de una √∫nica funci√≥n ayuda a que el c√≥digo sea m√°s claro y f√°cil de mantener. Cada m√©todo se encarga de una tarea concreta y puede probarse de forma independiente.

Extensibilidad: Por ejemplo, pude haberse a√±adido un m√©todo para datos character que convierta la variable a factor (como se mostr√≥) o bien que presente un control de b√∫squeda. Adem√°s, el m√©todo por defecto en filter_var.default() garantiza que si se encuentra con un tipo no soportado, la fila se incluye sin filtrar‚Äîpermitiendo que la funci√≥n siga operando sin lanzar errores.

Aplicaci√≥n en UI din√°mica: En el ejemplo de Shiny, se genera la interfaz de forma din√°mica recorriendo las columnas del dataset. Esto permite que, al cambiar los datos o al usar distintos datasets, la UI se adapte autom√°ticamente sin necesidad de c√≥digo adicional.

```{r, eval=FALSE}
library(purrr)
library(dplyr)

# Funciones gen√©ricas para crear controles de UI seg√∫n el tipo de dato

# Definici√≥n de la funci√≥n gen√©rica make_ui
make_ui <- function(x, var) {
  UseMethod("make_ui", x)
}

# Para datos num√©ricos: se crea un sliderInput utilizando el rango de los datos.
make_ui.numeric <- function(x, var) {
  rng <- range(x, na.rm = TRUE)
  # Verifica que el rango sea v√°lido
  if(any(is.infinite(rng)) || any(is.na(rng))) {
    return(NULL)
  }
  sliderInput(
    inputId = var,
    label   = var,
    min     = rng[1],
    max     = rng[2],
    value   = rng
  )
}

# Para datos de tipo factor: se genera un selectInput con selecci√≥n m√∫ltiple.
make_ui.factor <- function(x, var) {
  levs <- levels(x)
  if(is.null(levs)) return(NULL)
  selectInput(
    inputId  = var,
    label    = var,
    choices  = levs,
    selected = levs,
    multiple = TRUE
  )
}

# Para datos de tipo character. Se puede tratar los caracteres convirti√©ndolos a factor,
# o bien se puede definir un control espec√≠fico. Aqu√≠ optamos por convertir y reutilizar la l√≥gica de factor.
make_ui.character <- function(x, var) {
  x <- as.factor(x)
  make_ui.factor(x, var)
}

# M√©todo por defecto: en caso de no soportar el tipo de dato, no se genera ning√∫n control.
make_ui.default <- function(x, var) {
  NULL
}


# Funciones gen√©ricas para filtrar datos seg√∫n el control generado

# Definici√≥n de la funci√≥n gen√©rica filter_var
filter_var <- function(x, val) {
  UseMethod("filter_var", x)
}

# Para datos num√©ricos: se espera que 'val' sea un vector de longitud 2 (m√≠nimo y m√°ximo)
filter_var.numeric <- function(x, val) {
  !is.na(x) & x >= val[1] & x <= val[2]
}

# Para datos tipo factor: el filtrado consiste en comprobar si el valor de x est√° en la selecci√≥n val.
filter_var.factor <- function(x, val) {
  x %in% val
}

# Para datos tipo character: se puede aplicar una l√≥gica similar a la de factor.
filter_var.character <- function(x, val) {
  x %in% val
}

# M√©todo por defecto: si el tipo no tiene un control asociado, no se aplica filtrado
filter_var.default <- function(x, val) {
  rep(TRUE, length(x))
}


# Lista de data frames en 'datasets'
dfs <- keep(ls("package:datasets"), ~ is.data.frame(get(.x, "package:datasets")))

ui <- fluidPage(
  sidebarLayout(
    sidebarPanel(
      selectInput("dataset", label = "Dataset", choices = dfs),
      uiOutput("filter") # Lugar para los controles de filtro
    ),
    mainPanel(
      tableOutput("data")
    )
  )
)

server <- function(input, output, session) {
  # Datos seleccionados
  data <- reactive({
    req(input$dataset) # nos aseguramos que input$dataset sea truthy (que no sea FALSE, NULL,"", etc)
    get(input$dataset, "package:datasets") # devuelve el objeto que tiene el nombre input$dataset
  })
  
  # Nombres de variables del dataset
  vars <- reactive(names(data())) # necesitaremos un vector de nombres (lo que es usual en programaci√≥n funcional)
  
  # Genera los controles de filtro en la UI
  output$filter <- renderUI({
      # data()[[.x]] es la forma de conseguir el vector desde el reactivo de los nombres: vars()
      # .x es la forma de conseguir el nombre desde vars()
    map(vars(), ~ make_ui(data()[[.x]], .x)) # con los vectores y los nombres genera los input
  })
  
  # L√≥gica de filtrado combinada (selected() es un reactivo que devuelve un vector l√≥gico)
  selected <- reactive({
    # Aplica filter_var a cada variable/input correspondiente
    each_var <- map(vars(), ~ filter_var(data()[[.x]], input[[.x]])) # 
    # Combina todos los vectores l√≥gicos con &, o sea con la operaci√≥n logical1 & logical2 & logical3
      # reduce(list(TRUE, TRUE, TRUE), `&`) # que es como (TRUE & TRUE) & TRUE
      # [1] TRUE
      # reduce(list(TRUE, TRUE, FALSE), `&`)
      # [1] FALSE
    reduce(each_var, `&`)
    # Alternativa base R: Reduce(`&`, each_var)
  })
  
  # Muestra la tabla filtrada
  output$data <- renderTable({
    req(selected()) # Espera a que el filtro est√© listo
    head(data()[selected(), , drop = FALSE], 12) # drop=FALSE por si queda 1 col, que no intente convertirlo en un vector (ver el par√°metro drop en la ayuda de ?`[`)
  })
}

shinyApp(ui, server)
```


::: notes
Finalmente, algunos ejercicios para `renderUI` y conceptos avanzados:

1.  **Alternativa a `renderUI`:** Intenten reimplementar el primer ejemplo de `renderUI` (el slider/numeric input din√°mico) usando `conditionalPanel` o un `tabsetPanel` oculto. Piensen en c√≥mo asegurar que el valor del input se mantenga sincronizado entre el slider y el numeric input cuando se cambian.

2.  **Contrase√±a Modal:** El ejercicio del libro profundiza en el comportamiento de la contrase√±a del modal. Les invito a explorar el porqu√© la contrase√±a "desaparece" visualmente y c√≥mo podr√≠an mantenerla si fuera necesario (aunque no siempre es deseable por seguridad).

3.  **`isolate()`:** Este es clave para entender la reactividad. Quiten `isolate()` del ejemplo de `renderUI` que preserva el estado y observen qu√© sucede. Ver√°n c√≥mo se crea un bucle reactivo, ya que el `renderUI` se disparar√≠a continuamente cada vez que el valor del input generado cambiara, intentando re-renderizarlo, lo que lo volver√≠a a cambiar, y as√≠ sucesivamente.

4.  **Soporte Fechas:** Extiendan las funciones `make_ui` y `filter_var` de nuestro ejemplo de filtrado din√°mico para que tambi√©n puedan manejar columnas de tipo `Date` o `POSIXct` (fecha y hora), probablemente utilizando `dateRangeInput`.

5.  **Avanzado S3:** Para aquellos con conocimientos de programaci√≥n orientada a objetos en R, un desaf√≠o es reemplazar las sentencias `if/else` dentro de `make_ui` y `filter_var` por un sistema de m√©todos S3, lo que har√≠a el c√≥digo m√°s extensible para nuevos tipos de columna.

Espero que estos ejercicios les permitan profundizar en el uso de estas herramientas.
:::

------------------------------------------------------------------------

## Resumen: UI Din√°mica

Hemos visto tres formas de hacer la UI m√°s interactiva:

1.  **`update*Input()`:** Modificar controles existentes. Ideal para cambios simples (valor, etiqueta, opciones, rango).
2.  **`tabsetPanel(type = "hidden")` + `updateTabsetPanel()`:** Mostrar/ocultar secciones predefinidas. Bueno para UI condicional o wizards.
3.  **`renderUI()` + `uiOutput()`:** Generar UI arbitraria desde el servidor. M√°xima flexibilidad, pero m√°s complejo y puede tener latencia. Requiere cuidado para preservar estado (`isolate`).

**Recordatorio:** ¬°La UI din√°mica a√±ade complejidad! - Usa la t√©cnica m√°s simple posible. - Cuidado con referencias circulares y estado transitorio (`freezeReactiveValue`). - La programaci√≥n funcional (`map`, `reduce`) es muy √∫til para generar UI compleja.

::: notes
Para cerrar, recapitulemos las tres t√©cnicas clave para la UI din√°mica que hemos explorado hoy:

1.  **`update*Input()`:** Esta es su herramienta de referencia para modificaciones menores en controles de entrada ya existentes. Es ideal para cambiar un valor, una etiqueta, las opciones disponibles o el rango de un slider. Es la m√°s sencilla y directa.

2.  **`tabsetPanel(type = "hidden")` junto con `updateTabsetPanel()`:** Esta t√©cnica es fant√°stica para mostrar u ocultar grandes bloques de UI que ya est√°n predefinidos. Es perfecta para UIs condicionales (como mostrar par√°metros de distribuci√≥n espec√≠ficos) o para construir interfaces de asistente paso a paso.

3.  **`renderUI()` y `uiOutput()`:** Cuando necesitan la m√°xima flexibilidad, esta es la t√©cnica a usar. Les permite generar cualquier tipo y n√∫mero de componentes de UI directamente desde el servidor. Es la m√°s potente, pero tambi√©n la m√°s compleja y puede introducir latencia. Requiere especial atenci√≥n para preservar el estado del usuario usando `isolate()`.

Como recordatorio final, aunque la UI din√°mica es incre√≠blemente poderosa y es lo que realmente da vida a nuestras aplicaciones Shiny, siempre recuerden que a√±ade complejidad. - Siempre opten por la t√©cnica m√°s simple que resuelva su problema. - Sean extremadamente cuidadosos con las referencias circulares y gestionen el estado transitorio con herramientas como `freezeReactiveValue()`. - Y no subestimen el poder de la programaci√≥n funcional con paquetes como `purrr` para generar y gestionar UIs complejas de manera concisa.

¬°Muchas gracias por su atenci√≥n! Espero que esta presentaci√≥n les haya dado las herramientas y la confianza para crear aplicaciones Shiny a√∫n m√°s din√°micas y robustas. ¬øHay alguna pregunta?
:::

# Muchas Gracias {.text-center}


:::footnote
Por la paciencia y por el apoyo ü§ó
:::